{
	"address": "0xc8539eaC81dFF9a88EB9A1facD1a4fB3ff08bE93",
	"abi": [
		{
			"inputs": [
				{
					"internalType": "bytes4",
					"name": "_functionSelector",
					"type": "bytes4"
				}
			],
			"name": "facetAddress",
			"outputs": [
				{
					"internalType": "address",
					"name": "facetAddress_",
					"type": "address"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "facetAddresses",
			"outputs": [
				{
					"internalType": "address[]",
					"name": "facetAddresses_",
					"type": "address[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "address",
					"name": "_facet",
					"type": "address"
				}
			],
			"name": "facetFunctionSelectors",
			"outputs": [
				{
					"internalType": "bytes4[]",
					"name": "_facetFunctionSelectors",
					"type": "bytes4[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [],
			"name": "facets",
			"outputs": [
				{
					"components": [
						{
							"internalType": "address",
							"name": "facetAddress",
							"type": "address"
						},
						{
							"internalType": "bytes4[]",
							"name": "functionSelectors",
							"type": "bytes4[]"
						}
					],
					"internalType": "struct IDiamondLoupe.Facet[]",
					"name": "facets_",
					"type": "tuple[]"
				}
			],
			"stateMutability": "view",
			"type": "function"
		},
		{
			"inputs": [
				{
					"internalType": "bytes4",
					"name": "_interfaceId",
					"type": "bytes4"
				}
			],
			"name": "supportsInterface",
			"outputs": [
				{
					"internalType": "bool",
					"name": "",
					"type": "bool"
				}
			],
			"stateMutability": "view",
			"type": "function"
		}
	],
	"transactionHash": "0xfaca61291562c65611ad02681d760d1df11407df565a1e45903c6cfaed071571",
	"receipt": {
		"to": null,
		"from": "0x97C860be7A003938a916e8633dD3E8d45Bcd0028",
		"contractAddress": "0xc8539eaC81dFF9a88EB9A1facD1a4fB3ff08bE93",
		"transactionIndex": 8,
		"gasUsed": "636535",
		"logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		"blockHash": "0x15d556532d00f57541a68b5331cfa1ee8c58680136e780dedcd830df40c839de",
		"transactionHash": "0xfaca61291562c65611ad02681d760d1df11407df565a1e45903c6cfaed071571",
		"logs": [],
		"blockNumber": 125054214,
		"cumulativeGasUsed": "2349340",
		"status": 1,
		"byzantium": true
	},
	"args": [],
	"numDeployments": 1,
	"solcInputHash": "2ccc6644f36fe7c7b6b0f443317deda8",
	"metadata": "{\"compiler\":{\"version\":\"0.8.22+commit.4fc1097e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_facetFunctionSelectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"details\":\"If facet is not found return address(0).\",\"params\":{\"_functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"facetAddresses_\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"_facet\":\"The facet address.\"},\"returns\":{\"_facetFunctionSelectors\":\"The selectors associated with a facet address.\"}},\"facets()\":{\"returns\":{\"facets_\":\"Facet\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet that supports the given selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by a diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors supported by a specific facet.\"},\"facets()\":{\"notice\":\"Gets all facets and their selectors.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets-diamond/DiamondLoupeFacet.sol\":\"DiamondLoupeFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"contracts/facets-diamond/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\\nimport {IDiamondLoupe} from '../interfaces/IDiamondLoupe.sol';\\nimport {IERC165} from '../interfaces/IERC165.sol';\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n\\t/// @notice Gets all facets and their selectors.\\n\\t/// @return facets_ Facet\\n\\tfunction facets() external view override returns (Facet[] memory facets_) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\tfacets_ = new Facet[](ds.selectorCount);\\n\\t\\tuint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\\n\\t\\tuint256 numFacets;\\n\\t\\tuint256 selectorIndex;\\n\\t\\t// loop through function selectors\\n\\t\\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n\\t\\t\\tbytes32 slot = ds.selectorSlots[slotIndex];\\n\\t\\t\\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\tif (selectorIndex > ds.selectorCount) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\t\\t\\t\\taddress facetAddress_ = address(bytes20(ds.facets[selector]));\\n\\t\\t\\t\\tbool continueLoop;\\n\\t\\t\\t\\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n\\t\\t\\t\\t\\tif (facets_[facetIndex].facetAddress == facetAddress_) {\\n\\t\\t\\t\\t\\t\\tfacets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\\n\\t\\t\\t\\t\\t\\t// probably will never have more than 256 functions from one facet contract\\n\\t\\t\\t\\t\\t\\trequire(numFacetSelectors[facetIndex] < 255);\\n\\t\\t\\t\\t\\t\\tnumFacetSelectors[facetIndex]++;\\n\\t\\t\\t\\t\\t\\tcontinueLoop = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (continueLoop) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfacets_[numFacets].facetAddress = facetAddress_;\\n\\t\\t\\t\\tfacets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\\n\\t\\t\\t\\tfacets_[numFacets].functionSelectors[0] = selector;\\n\\t\\t\\t\\tnumFacetSelectors[numFacets] = 1;\\n\\t\\t\\t\\tnumFacets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n\\t\\t\\tuint256 numSelectors = numFacetSelectors[facetIndex];\\n\\t\\t\\tbytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\n\\t\\t\\t// setting the number of selectors\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tmstore(selectors, numSelectors)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// setting the number of facets\\n\\t\\tassembly {\\n\\t\\t\\tmstore(facets_, numFacets)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Gets all the function selectors supported by a specific facet.\\n\\t/// @param _facet The facet address.\\n\\t/// @return _facetFunctionSelectors The selectors associated with a facet address.\\n\\tfunction facetFunctionSelectors(\\n\\t\\taddress _facet\\n\\t) external view override returns (bytes4[] memory _facetFunctionSelectors) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\tuint256 numSelectors;\\n\\t\\t_facetFunctionSelectors = new bytes4[](ds.selectorCount);\\n\\t\\tuint256 selectorIndex;\\n\\t\\t// loop through function selectors\\n\\t\\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n\\t\\t\\tbytes32 slot = ds.selectorSlots[slotIndex];\\n\\t\\t\\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\tif (selectorIndex > ds.selectorCount) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\t\\t\\t\\taddress facet = address(bytes20(ds.facets[selector]));\\n\\t\\t\\t\\tif (_facet == facet) {\\n\\t\\t\\t\\t\\t_facetFunctionSelectors[numSelectors] = selector;\\n\\t\\t\\t\\t\\tnumSelectors++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Set the number of selectors in the array\\n\\t\\tassembly {\\n\\t\\t\\tmstore(_facetFunctionSelectors, numSelectors)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Get all the facet addresses used by a diamond.\\n\\t/// @return facetAddresses_\\n\\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\tfacetAddresses_ = new address[](ds.selectorCount);\\n\\t\\tuint256 numFacets;\\n\\t\\tuint256 selectorIndex;\\n\\t\\t// loop through function selectors\\n\\t\\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\\n\\t\\t\\tbytes32 slot = ds.selectorSlots[slotIndex];\\n\\t\\t\\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\\n\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\tif (selectorIndex > ds.selectorCount) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\t\\t\\t\\taddress facetAddress_ = address(bytes20(ds.facets[selector]));\\n\\t\\t\\t\\tbool continueLoop;\\n\\t\\t\\t\\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n\\t\\t\\t\\t\\tif (facetAddress_ == facetAddresses_[facetIndex]) {\\n\\t\\t\\t\\t\\t\\tcontinueLoop = true;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (continueLoop) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfacetAddresses_[numFacets] = facetAddress_;\\n\\t\\t\\t\\tnumFacets++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Set the number of facet addresses in the array\\n\\t\\tassembly {\\n\\t\\t\\tmstore(facetAddresses_, numFacets)\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Gets the facet that supports the given selector.\\n\\t/// @dev If facet is not found return address(0).\\n\\t/// @param _functionSelector The function selector.\\n\\t/// @return facetAddress_ The facet address.\\n\\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\tfacetAddress_ = address(bytes20(ds.facets[_functionSelector]));\\n\\t}\\n\\n\\t// This implements ERC-165.\\n\\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\treturn ds.supportedInterfaces[_interfaceId];\\n\\t}\\n}\\n\",\"keccak256\":\"0xc1a9dcc65eef848a9fda89e4955181019669871a6cc4674c6ec6a2d8e52822ff\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n\\tenum FacetCutAction {\\n\\t\\tAdd,\\n\\t\\tReplace,\\n\\t\\tRemove\\n\\t}\\n\\t// Add=0, Replace=1, Remove=2\\n\\n\\tstruct FacetCut {\\n\\t\\taddress facetAddress;\\n\\t\\tFacetCutAction action;\\n\\t\\tbytes4[] functionSelectors;\\n\\t}\\n\\n\\t/// @notice Add/replace/remove any number of functions and optionally execute\\n\\t///         a function with delegatecall\\n\\t/// @param _diamondCut Contains the facet addresses and function selectors\\n\\t/// @param _init The address of the contract or facet to execute _calldata\\n\\t/// @param _calldata A function call, including function selector and arguments\\n\\t///                  _calldata is executed with delegatecall on _init\\n\\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n\\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xf92889a9e14ab87d3c46ffe838894453d3a86e5d6433b549c3ec2b2dd788a623\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    /// These functions are expected to be called frequently\\r\\n    /// by tools.\\r\\n\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\",\"keccak256\":\"0x2e3699584683471d7411a5986ab204dfdb9754c6c9fb5e5716d0831a8b7c0060\",\"license\":\"MIT\"},\"contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n\\t/// @notice Query if a contract implements an interface\\n\\t/// @param interfaceId The interface identifier, as specified in ERC-165\\n\\t/// @dev Interface identification is specified in ERC-165. This function\\n\\t///  uses less than 30,000 gas.\\n\\t/// @return `true` if the contract implements `interfaceID` and\\n\\t///  `interfaceID` is not 0xffffffff, `false` otherwise\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc5bff2ff127c6d712e389b829050439e694004142d69d664036844b79bbcc46b\",\"license\":\"MIT\"},\"contracts/interfaces/IERC173.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n\\t/// @dev This emits when ownership of a contract changes.\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n\\t/// @notice Get the address of the owner\\n\\t/// @return owner_ The address of the owner.\\n\\tfunction owner() external view returns (address owner_);\\n\\n\\t/// @notice Set the address of the new owner of the contract\\n\\t/// @dev Set _newOwner to address(0) to renounce any ownership.\\n\\t/// @param _newOwner The address of the new owner of the contract\\n\\tfunction transferOwnership(address _newOwner) external;\\n}\\n\",\"keccak256\":\"0x3c7a88d2e78d66154b0fb99bcd6bf3c86ea220dc7624672004a4934683490e71\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\\nimport {IERC173} from '../interfaces/IERC173.sol';\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n\\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.diamond.storage');\\n\\n\\terror OwnableUnauthorizedAccount(address _invalidAddress);\\n\\terror OwnableInvalidOwner(address _owner);\\n\\n\\tstruct DiamondStorage {\\n\\t\\t// maps function selectors to the facets that execute the functions.\\n\\t\\t// and maps the selectors to their position in the selectorSlots array.\\n\\t\\t// func selector => address facet, selector position\\n\\t\\tmapping(bytes4 => bytes32) facets;\\n\\t\\t// array of slots of function selectors.\\n\\t\\t// each slot holds 8 function selectors.\\n\\t\\tmapping(uint256 => bytes32) selectorSlots;\\n\\t\\t// The number of function selectors in selectorSlots\\n\\t\\tuint16 selectorCount;\\n\\t\\t// Used to query if a contract implements an interface.\\n\\t\\t// Used to implement ERC-165.\\n\\t\\tmapping(bytes4 => bool) supportedInterfaces;\\n\\t\\t// owner of the contract\\n\\t\\taddress contractOwner;\\n\\t}\\n\\n\\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n\\t\\tbytes32 position = DIAMOND_STORAGE_POSITION;\\n\\t\\tassembly {\\n\\t\\t\\tds.slot := position\\n\\t\\t}\\n\\t}\\n\\n\\t// move ownership stuff to Ownership facet\\n\\tfunction setContractOwner(address _newOwner) internal {\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\n\\t\\taddress previousOwner = ds.contractOwner;\\n\\t\\tds.contractOwner = _newOwner;\\n\\t\\temit IERC173.OwnershipTransferred(previousOwner, _newOwner);\\n\\t}\\n\\n\\tfunction contractOwner() internal view returns (address contractOwner_) {\\n\\t\\tcontractOwner_ = diamondStorage().contractOwner;\\n\\t}\\n\\n\\tfunction enforceIsContractOwner() internal view {\\n\\t\\tif (msg.sender != diamondStorage().contractOwner) {\\n\\t\\t\\trevert OwnableUnauthorizedAccount(msg.sender);\\n\\t\\t}\\n\\t}\\n\\n\\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n\\tbytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n\\tbytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n\\t// Internal function version of diamondCut\\n\\t// This code is almost the same as the external diamondCut,\\n\\t// except it is using 'Facet[] memory _diamondCut' instead of\\n\\t// 'Facet[] calldata _diamondCut'.\\n\\t// The code is duplicated to prevent copying calldata to memory which\\n\\t// causes an error for a two dimensional array.\\n\\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\n\\t\\tuint256 originalSelectorCount = ds.selectorCount;\\n\\t\\tuint256 selectorCount = originalSelectorCount;\\n\\t\\tbytes32 selectorSlot;\\n\\t\\t// Check if last selector slot is not full\\n\\t\\t// \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n\\t\\tif (selectorCount & 7 > 0) {\\n\\t\\t\\t// get last selectorSlot\\n\\t\\t\\t// \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n\\t\\t\\tselectorSlot = ds.selectorSlots[selectorCount >> 3];\\n\\t\\t}\\n\\t\\t// loop through diamond cut\\n\\t\\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n\\t\\t\\t(selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n\\t\\t\\t\\tselectorCount,\\n\\t\\t\\t\\tselectorSlot,\\n\\t\\t\\t\\t_diamondCut[facetIndex].facetAddress,\\n\\t\\t\\t\\t_diamondCut[facetIndex].action,\\n\\t\\t\\t\\t_diamondCut[facetIndex].functionSelectors\\n\\t\\t\\t);\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tfacetIndex++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (selectorCount != originalSelectorCount) {\\n\\t\\t\\tds.selectorCount = uint16(selectorCount);\\n\\t\\t}\\n\\t\\t// If last selector slot is not full\\n\\t\\t// \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n\\t\\tif (selectorCount & 7 > 0) {\\n\\t\\t\\t// \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n\\t\\t\\tds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n\\t\\t}\\n\\t\\temit DiamondCut(_diamondCut, _init, _calldata);\\n\\t\\tinitializeDiamondCut(_init, _calldata);\\n\\t}\\n\\n\\tfunction addReplaceRemoveFacetSelectors(\\n\\t\\tuint256 _selectorCount,\\n\\t\\tbytes32 _selectorSlot,\\n\\t\\taddress _newFacetAddress,\\n\\t\\tIDiamondCut.FacetCutAction _action,\\n\\t\\tbytes4[] memory _selectors\\n\\t) internal returns (uint256, bytes32) {\\n\\t\\tDiamondStorage storage ds = diamondStorage();\\n\\t\\trequire(_selectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n\\t\\tif (_action == IDiamondCut.FacetCutAction.Add) {\\n\\t\\t\\tenforceHasContractCode(_newFacetAddress, 'LibDiamondCut: Add facet has no code');\\n\\t\\t\\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n\\t\\t\\t\\tbytes4 selector = _selectors[selectorIndex];\\n\\t\\t\\t\\tbytes32 oldFacet = ds.facets[selector];\\n\\t\\t\\t\\trequire(address(bytes20(oldFacet)) == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n\\t\\t\\t\\t// add facet for selector\\n\\t\\t\\t\\tds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n\\t\\t\\t\\t// \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\tuint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n\\t\\t\\t\\t// clear selector position in slot and add selector\\n\\t\\t\\t\\t_selectorSlot =\\n\\t\\t\\t\\t\\t(_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n\\t\\t\\t\\t\\t(bytes32(selector) >> selectorInSlotPosition);\\n\\t\\t\\t\\t// if slot is full then write it to storage\\n\\t\\t\\t\\tif (selectorInSlotPosition == 224) {\\n\\t\\t\\t\\t\\t// \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n\\t\\t\\t\\t\\tds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n\\t\\t\\t\\t\\t_selectorSlot = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t_selectorCount++;\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n\\t\\t\\tenforceHasContractCode(_newFacetAddress, 'LibDiamondCut: Replace facet has no code');\\n\\t\\t\\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n\\t\\t\\t\\tbytes4 selector = _selectors[selectorIndex];\\n\\t\\t\\t\\tbytes32 oldFacet = ds.facets[selector];\\n\\t\\t\\t\\taddress oldFacetAddress = address(bytes20(oldFacet));\\n\\t\\t\\t\\t// only useful if immutable functions exist\\n\\t\\t\\t\\trequire(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n\\t\\t\\t\\trequire(oldFacetAddress != _newFacetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n\\t\\t\\t\\trequire(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n\\t\\t\\t\\t// replace old facet address\\n\\t\\t\\t\\tds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n\\t\\t\\trequire(_newFacetAddress == address(0), 'LibDiamondCut: Remove facet address must be address(0)');\\n\\t\\t\\t// \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n\\t\\t\\tuint256 selectorSlotCount = _selectorCount >> 3;\\n\\t\\t\\t// \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n\\t\\t\\tuint256 selectorInSlotIndex = _selectorCount & 7;\\n\\t\\t\\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n\\t\\t\\t\\tif (selectorInSlotIndex == 0) {\\n\\t\\t\\t\\t\\t// get last selectorSlot\\n\\t\\t\\t\\t\\tselectorSlotCount--;\\n\\t\\t\\t\\t\\t_selectorSlot = ds.selectorSlots[selectorSlotCount];\\n\\t\\t\\t\\t\\tselectorInSlotIndex = 7;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tselectorInSlotIndex--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tbytes4 lastSelector;\\n\\t\\t\\t\\tuint256 oldSelectorsSlotCount;\\n\\t\\t\\t\\tuint256 oldSelectorInSlotPosition;\\n\\t\\t\\t\\t// adding a block here prevents stack too deep error\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tbytes4 selector = _selectors[selectorIndex];\\n\\t\\t\\t\\t\\tbytes32 oldFacet = ds.facets[selector];\\n\\t\\t\\t\\t\\trequire(\\n\\t\\t\\t\\t\\t\\taddress(bytes20(oldFacet)) != address(0),\\n\\t\\t\\t\\t\\t\\t\\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t// only useful if immutable functions exist\\n\\t\\t\\t\\t\\trequire(address(bytes20(oldFacet)) != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n\\t\\t\\t\\t\\t// replace selector with last selector in ds.facets\\n\\t\\t\\t\\t\\t// gets the last selector\\n\\t\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\t\\tlastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n\\t\\t\\t\\t\\tif (lastSelector != selector) {\\n\\t\\t\\t\\t\\t\\t// update last selector slot position info\\n\\t\\t\\t\\t\\t\\tds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdelete ds.facets[selector];\\n\\t\\t\\t\\t\\tuint256 oldSelectorCount = uint16(uint256(oldFacet));\\n\\t\\t\\t\\t\\t// \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n\\t\\t\\t\\t\\toldSelectorsSlotCount = oldSelectorCount >> 3;\\n\\t\\t\\t\\t\\t// \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n\\t\\t\\t\\t\\t// \\\" << 5 is the same as multiplying by 32 ( * 32)\\n\\t\\t\\t\\t\\toldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (oldSelectorsSlotCount != selectorSlotCount) {\\n\\t\\t\\t\\t\\tbytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\\n\\t\\t\\t\\t\\t// clears the selector we are deleting and puts the last selector in its place.\\n\\t\\t\\t\\t\\toldSelectorSlot =\\n\\t\\t\\t\\t\\t\\t(oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n\\t\\t\\t\\t\\t\\t(bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\t\\t\\t\\t\\t// update storage with the modified slot\\n\\t\\t\\t\\t\\tds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// clears the selector we are deleting and puts the last selector in its place.\\n\\t\\t\\t\\t\\t_selectorSlot =\\n\\t\\t\\t\\t\\t\\t(_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n\\t\\t\\t\\t\\t\\t(bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (selectorInSlotIndex == 0) {\\n\\t\\t\\t\\t\\tdelete ds.selectorSlots[selectorSlotCount];\\n\\t\\t\\t\\t\\t_selectorSlot = 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tselectorIndex++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t_selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n\\t\\t} else {\\n\\t\\t\\trevert('LibDiamondCut: Incorrect FacetCutAction');\\n\\t\\t}\\n\\t\\treturn (_selectorCount, _selectorSlot);\\n\\t}\\n\\n\\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n\\t\\tif (_init == address(0)) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tenforceHasContractCode(_init, 'LibDiamondCut: _init address has no code');\\n\\t\\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\\n\\t\\tif (!success) {\\n\\t\\t\\tif (error.length > 0) {\\n\\t\\t\\t\\t// bubble up error\\n\\t\\t\\t\\t/// @solidity memory-safe-assembly\\n\\t\\t\\t\\tassembly {\\n\\t\\t\\t\\t\\tlet returndata_size := mload(error)\\n\\t\\t\\t\\t\\trevert(add(32, error), returndata_size)\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trevert InitializationFunctionReverted(_init, _calldata);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n\\t\\tuint256 contractSize;\\n\\t\\tassembly {\\n\\t\\t\\tcontractSize := extcodesize(_contract)\\n\\t\\t}\\n\\t\\trequire(contractSize > 0, _errorMessage);\\n\\t}\\n}\\n\",\"keccak256\":\"0xd3bb09562891df5dc9d7a1b36d2a90e451c01ca00a3b88112c791dce5bf8ced7\",\"license\":\"MIT\"}},\"version\":1}",
	"bytecode": "0x608060405234801561001057600080fd5b50610a8c806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806352ef6b2c146100845780637a0ed62714610099578063adfca15e146100ae578063cdffacc6146100ce575b600080fd5b61006f61006a36600461085b565b6100f9565b60405190151581526020015b60405180910390f35b61008c61012a565b60405161007b919061088c565b6100a16102b8565b60405161007b919061091f565b6100c16100bc36600461099e565b6106c3565b60405161007b91906109c7565b6100e16100dc36600461085b565b610808565b6040516001600160a01b03909116815260200161007b565b600080610104610837565b6001600160e01b0319909316600090815260039093016020525050604090205460ff1690565b60606000610136610837565b600281015490915061ffff166001600160401b03811115610159576101596109da565b604051908082528060200260200182016040528015610182578160200160208202803683370190505b50915060008060005b600284015461ffff168210156102b0576000818152600185016020526040812054905b600881101561029b57836101c181610a06565b600288015490955061ffff168511905061029b57600581901b82901b6001600160e01b0319811660009081526020889052604081205460601c90805b88811015610248578a818151811061021757610217610a1f565b60200260200101516001600160a01b0316836001600160a01b0316036102405760019150610248565b6001016101fd565b50801561025757505050610293565b818a898151811061026a5761026a610a1f565b6001600160a01b03909216602092830291909101909101528761028c81610a06565b9850505050505b6001016101ae565b505080806102a890610a06565b91505061018b565b505082525090565b606060006102c4610837565b600281015490915061ffff166001600160401b038111156102e7576102e76109da565b60405190808252806020026020018201604052801561032d57816020015b6040805180820190915260008152606060208201528152602001906001900390816103055790505b50600282015490925060009061ffff166001600160401b03811115610354576103546109da565b60405190808252806020026020018201604052801561037d578160200160208202803683370190505b50905060008060005b600285015461ffff1682101561065b576000818152600186016020526040812054905b600881101561064657836103bc81610a06565b600289015490955061ffff168511905061064657600581901b82901b6001600160e01b0319811660009081526020899052604081205460601c90805b8881101561050e57826001600160a01b03168c828151811061041c5761041c610a1f565b6020026020010151600001516001600160a01b03160361050657838c828151811061044957610449610a1f565b6020026020010151602001518b838151811061046757610467610a1f565b602002602001015161ffff168151811061048357610483610a1f565b60200260200101906001600160e01b03191690816001600160e01b0319168152505060ff8a82815181106104b9576104b9610a1f565b602002602001015161ffff16106104cf57600080fd5b8981815181106104e1576104e1610a1f565b6020026020010180518091906104f690610a35565b61ffff169052506001915061050e565b6001016103f8565b50801561051d5750505061063e565b818b898151811061053057610530610a1f565b60209081029190910101516001600160a01b03909116905260028a015461ffff166001600160401b03811115610568576105686109da565b604051908082528060200260200182016040528015610591578160200160208202803683370190505b508b89815181106105a4576105a4610a1f565b602002602001015160200181905250828b89815181106105c6576105c6610a1f565b6020026020010151602001516000815181106105e4576105e4610a1f565b60200260200101906001600160e01b03191690816001600160e01b03191681525050600189898151811061061a5761061a610a1f565b61ffff909216602092830291909101909101528761063781610a06565b9850505050505b6001016103a9565b5050808061065390610a06565b915050610386565b5060005b828110156106b857600084828151811061067b5761067b610a1f565b602002602001015161ffff169050600087838151811061069d5761069d610a1f565b6020908102919091018101510151919091525060010161065f565b508185525050505090565b606060006106cf610837565b600281015490915060009061ffff166001600160401b038111156106f5576106f56109da565b60405190808252806020026020018201604052801561071e578160200160208202803683370190505b5092506000805b600284015461ffff168210156107fe576000818152600185016020526040812054905b60088110156107e9578361075b81610a06565b600288015490955061ffff16851190506107e957600581901b82901b6001600160e01b0319811660009081526020889052604090205460601c6001600160a01b038a168190036107df57818988815181106107b8576107b8610a1f565b6001600160e01b031990921660209283029190910190910152866107db81610a06565b9750505b5050600101610748565b505080806107f690610a06565b915050610725565b5050825250919050565b600080610813610837565b6001600160e01b031990931660009081526020939093525050604090205460601c90565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b60006020828403121561086d57600080fd5b81356001600160e01b03198116811461088557600080fd5b9392505050565b6020808252825182820181905260009190848201906040850190845b818110156108cd5783516001600160a01b0316835292840192918401916001016108a8565b50909695505050505050565b60008151808452602080850194506020840160005b838110156109145781516001600160e01b031916875295820195908201906001016108ee565b509495945050505050565b600060208083018184528085518083526040925060408601915060408160051b87010184880160005b8381101561099057888303603f19018552815180516001600160a01b0316845287015187840187905261097d878501826108d9565b9588019593505090860190600101610948565b509098975050505050505050565b6000602082840312156109b057600080fd5b81356001600160a01b038116811461088557600080fd5b60208152600061088560208301846108d9565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201610a1857610a186109f0565b5060010190565b634e487b7160e01b600052603260045260246000fd5b600061ffff808316818103610a4c57610a4c6109f0565b600101939250505056fea264697066735822122078435cab12f092651bb9fa964a82ce2fb845d3b0405bb6df12d0aa554658437f64736f6c63430008160033",
	"deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806352ef6b2c146100845780637a0ed62714610099578063adfca15e146100ae578063cdffacc6146100ce575b600080fd5b61006f61006a36600461085b565b6100f9565b60405190151581526020015b60405180910390f35b61008c61012a565b60405161007b919061088c565b6100a16102b8565b60405161007b919061091f565b6100c16100bc36600461099e565b6106c3565b60405161007b91906109c7565b6100e16100dc36600461085b565b610808565b6040516001600160a01b03909116815260200161007b565b600080610104610837565b6001600160e01b0319909316600090815260039093016020525050604090205460ff1690565b60606000610136610837565b600281015490915061ffff166001600160401b03811115610159576101596109da565b604051908082528060200260200182016040528015610182578160200160208202803683370190505b50915060008060005b600284015461ffff168210156102b0576000818152600185016020526040812054905b600881101561029b57836101c181610a06565b600288015490955061ffff168511905061029b57600581901b82901b6001600160e01b0319811660009081526020889052604081205460601c90805b88811015610248578a818151811061021757610217610a1f565b60200260200101516001600160a01b0316836001600160a01b0316036102405760019150610248565b6001016101fd565b50801561025757505050610293565b818a898151811061026a5761026a610a1f565b6001600160a01b03909216602092830291909101909101528761028c81610a06565b9850505050505b6001016101ae565b505080806102a890610a06565b91505061018b565b505082525090565b606060006102c4610837565b600281015490915061ffff166001600160401b038111156102e7576102e76109da565b60405190808252806020026020018201604052801561032d57816020015b6040805180820190915260008152606060208201528152602001906001900390816103055790505b50600282015490925060009061ffff166001600160401b03811115610354576103546109da565b60405190808252806020026020018201604052801561037d578160200160208202803683370190505b50905060008060005b600285015461ffff1682101561065b576000818152600186016020526040812054905b600881101561064657836103bc81610a06565b600289015490955061ffff168511905061064657600581901b82901b6001600160e01b0319811660009081526020899052604081205460601c90805b8881101561050e57826001600160a01b03168c828151811061041c5761041c610a1f565b6020026020010151600001516001600160a01b03160361050657838c828151811061044957610449610a1f565b6020026020010151602001518b838151811061046757610467610a1f565b602002602001015161ffff168151811061048357610483610a1f565b60200260200101906001600160e01b03191690816001600160e01b0319168152505060ff8a82815181106104b9576104b9610a1f565b602002602001015161ffff16106104cf57600080fd5b8981815181106104e1576104e1610a1f565b6020026020010180518091906104f690610a35565b61ffff169052506001915061050e565b6001016103f8565b50801561051d5750505061063e565b818b898151811061053057610530610a1f565b60209081029190910101516001600160a01b03909116905260028a015461ffff166001600160401b03811115610568576105686109da565b604051908082528060200260200182016040528015610591578160200160208202803683370190505b508b89815181106105a4576105a4610a1f565b602002602001015160200181905250828b89815181106105c6576105c6610a1f565b6020026020010151602001516000815181106105e4576105e4610a1f565b60200260200101906001600160e01b03191690816001600160e01b03191681525050600189898151811061061a5761061a610a1f565b61ffff909216602092830291909101909101528761063781610a06565b9850505050505b6001016103a9565b5050808061065390610a06565b915050610386565b5060005b828110156106b857600084828151811061067b5761067b610a1f565b602002602001015161ffff169050600087838151811061069d5761069d610a1f565b6020908102919091018101510151919091525060010161065f565b508185525050505090565b606060006106cf610837565b600281015490915060009061ffff166001600160401b038111156106f5576106f56109da565b60405190808252806020026020018201604052801561071e578160200160208202803683370190505b5092506000805b600284015461ffff168210156107fe576000818152600185016020526040812054905b60088110156107e9578361075b81610a06565b600288015490955061ffff16851190506107e957600581901b82901b6001600160e01b0319811660009081526020889052604090205460601c6001600160a01b038a168190036107df57818988815181106107b8576107b8610a1f565b6001600160e01b031990921660209283029190910190910152866107db81610a06565b9750505b5050600101610748565b505080806107f690610a06565b915050610725565b5050825250919050565b600080610813610837565b6001600160e01b031990931660009081526020939093525050604090205460601c90565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c90565b60006020828403121561086d57600080fd5b81356001600160e01b03198116811461088557600080fd5b9392505050565b6020808252825182820181905260009190848201906040850190845b818110156108cd5783516001600160a01b0316835292840192918401916001016108a8565b50909695505050505050565b60008151808452602080850194506020840160005b838110156109145781516001600160e01b031916875295820195908201906001016108ee565b509495945050505050565b600060208083018184528085518083526040925060408601915060408160051b87010184880160005b8381101561099057888303603f19018552815180516001600160a01b0316845287015187840187905261097d878501826108d9565b9588019593505090860190600101610948565b509098975050505050505050565b6000602082840312156109b057600080fd5b81356001600160a01b038116811461088557600080fd5b60208152600061088560208301846108d9565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201610a1857610a186109f0565b5060010190565b634e487b7160e01b600052603260045260246000fd5b600061ffff808316818103610a4c57610a4c6109f0565b600101939250505056fea264697066735822122078435cab12f092651bb9fa964a82ce2fb845d3b0405bb6df12d0aa554658437f64736f6c63430008160033",
	"devdoc": {
		"kind": "dev",
		"methods": {
			"facetAddress(bytes4)": {
				"details": "If facet is not found return address(0).",
				"params": {
					"_functionSelector": "The function selector."
				},
				"returns": {
					"facetAddress_": "The facet address."
				}
			},
			"facetAddresses()": {
				"returns": {
					"facetAddresses_": "facetAddresses_"
				}
			},
			"facetFunctionSelectors(address)": {
				"params": {
					"_facet": "The facet address."
				},
				"returns": {
					"_facetFunctionSelectors": "The selectors associated with a facet address."
				}
			},
			"facets()": {
				"returns": {
					"facets_": "Facet"
				}
			}
		},
		"version": 1
	},
	"userdoc": {
		"kind": "user",
		"methods": {
			"facetAddress(bytes4)": {
				"notice": "Gets the facet that supports the given selector."
			},
			"facetAddresses()": {
				"notice": "Get all the facet addresses used by a diamond."
			},
			"facetFunctionSelectors(address)": {
				"notice": "Gets all the function selectors supported by a specific facet."
			},
			"facets()": {
				"notice": "Gets all facets and their selectors."
			}
		},
		"version": 1
	},
	"storageLayout": {
		"storage": [],
		"types": null
	}
}
