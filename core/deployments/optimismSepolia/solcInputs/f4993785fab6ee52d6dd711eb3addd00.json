{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/EntropyErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary EntropyErrors {\n    // An invariant of the contract failed to hold. This error indicates a software logic bug.\n    // Signature: 0xd82dd966\n    error AssertionFailure();\n    // The provider being registered has already registered\n    // Signature: 0xda041bdf\n    error ProviderAlreadyRegistered();\n    // The requested provider does not exist.\n    // Signature: 0xdf51c431\n    error NoSuchProvider();\n    // The specified request does not exist.\n    // Signature: 0xc4237352\n    error NoSuchRequest();\n    // The randomness provider is out of commited random numbers. The provider needs to\n    // rotate their on-chain commitment to resolve this error.\n    // Signature: 0x3e515085\n    error OutOfRandomness();\n    // The transaction fee was not sufficient\n    // Signature: 0x025dbdd4\n    error InsufficientFee();\n    // Either the user's or the provider's revealed random values did not match their commitment.\n    // Signature: 0xb8be1a8d\n    error IncorrectRevelation();\n    // Governance message is invalid (e.g., deserialization error).\n    // Signature: 0xb463ce7a\n    error InvalidUpgradeMagic();\n    // The msg.sender is not allowed to invoke this call.\n    // Signature: 0x82b42900\n    error Unauthorized();\n    // The blockhash is 0.\n    // Signature: 0x92555c0e\n    error BlockhashUnavailable();\n    // if a request was made using `requestWithCallback`, request should be fulfilled using `revealWithCallback`\n    // else if a request was made using `request`, request should be fulfilled using `reveal`\n    // Signature: 0x50f0dc92\n    error InvalidRevealCall();\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/EntropyEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./EntropyStructs.sol\";\n\ninterface EntropyEvents {\n    event Registered(EntropyStructs.ProviderInfo provider);\n\n    event Requested(EntropyStructs.Request request);\n    event RequestedWithCallback(\n        address indexed provider,\n        address indexed requestor,\n        uint64 indexed sequenceNumber,\n        bytes32 userRandomNumber,\n        EntropyStructs.Request request\n    );\n\n    event Revealed(\n        EntropyStructs.Request request,\n        bytes32 userRevelation,\n        bytes32 providerRevelation,\n        bytes32 blockHash,\n        bytes32 randomNumber\n    );\n    event RevealedWithCallback(\n        EntropyStructs.Request request,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation,\n        bytes32 randomNumber\n    );\n\n    event ProviderFeeUpdated(address provider, uint128 oldFee, uint128 newFee);\n\n    event ProviderUriUpdated(address provider, bytes oldUri, bytes newUri);\n\n    event ProviderFeeManagerUpdated(\n        address provider,\n        address oldFeeManager,\n        address newFeeManager\n    );\n\n    event Withdrawal(\n        address provider,\n        address recipient,\n        uint128 withdrawnAmount\n    );\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\ncontract EntropyStructs {\n    struct ProviderInfo {\n        uint128 feeInWei;\n        uint128 accruedFeesInWei;\n        // The commitment that the provider posted to the blockchain, and the sequence number\n        // where they committed to this. This value is not advanced after the provider commits,\n        // and instead is stored to help providers track where they are in the hash chain.\n        bytes32 originalCommitment;\n        uint64 originalCommitmentSequenceNumber;\n        // Metadata for the current commitment. Providers may optionally use this field to help\n        // manage rotations (i.e., to pick the sequence number from the correct hash chain).\n        bytes commitmentMetadata;\n        // Optional URI where clients can retrieve revelations for the provider.\n        // Client SDKs can use this field to automatically determine how to retrieve random values for each provider.\n        // TODO: specify the API that must be implemented at this URI\n        bytes uri;\n        // The first sequence number that is *not* included in the current commitment (i.e., an exclusive end index).\n        // The contract maintains the invariant that sequenceNumber <= endSequenceNumber.\n        // If sequenceNumber == endSequenceNumber, the provider must rotate their commitment to add additional random values.\n        uint64 endSequenceNumber;\n        // The sequence number that will be assigned to the next inbound user request.\n        uint64 sequenceNumber;\n        // The current commitment represents an index/value in the provider's hash chain.\n        // These values are used to verify requests for future sequence numbers. Note that\n        // currentCommitmentSequenceNumber < sequenceNumber.\n        //\n        // The currentCommitment advances forward through the provider's hash chain as values\n        // are revealed on-chain.\n        bytes32 currentCommitment;\n        uint64 currentCommitmentSequenceNumber;\n        // An address that is authorized to set / withdraw fees on behalf of this provider.\n        address feeManager;\n    }\n\n    struct Request {\n        // Storage slot 1 //\n        address provider;\n        uint64 sequenceNumber;\n        // The number of hashes required to verify the provider revelation.\n        uint32 numHashes;\n        // Storage slot 2 //\n        // The commitment is keccak256(userCommitment, providerCommitment). Storing the hash instead of both saves 20k gas by\n        // eliminating 1 store.\n        bytes32 commitment;\n        // Storage slot 3 //\n        // The number of the block where this request was created.\n        // Note that we're using a uint64 such that we have an additional space for an address and other fields in\n        // this storage slot. Although block.number returns a uint256, 64 bits should be plenty to index all of the\n        // blocks ever generated.\n        uint64 blockNumber;\n        // The address that requested this random number.\n        address requester;\n        // If true, incorporate the blockhash of blockNumber into the generated random value.\n        bool useBlockhash;\n        // If true, the requester will be called back with the generated random value.\n        bool isRequestWithCallback;\n        // There are 2 remaining bytes of free space in this slot.\n    }\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/IEntropy.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nimport \"./EntropyEvents.sol\";\n\ninterface IEntropy is EntropyEvents {\n    // Register msg.sender as a randomness provider. The arguments are the provider's configuration parameters\n    // and initial commitment. Re-registering the same provider rotates the provider's commitment (and updates\n    // the feeInWei).\n    //\n    // chainLength is the number of values in the hash chain *including* the commitment, that is, chainLength >= 1.\n    function register(\n        uint128 feeInWei,\n        bytes32 commitment,\n        bytes calldata commitmentMetadata,\n        uint64 chainLength,\n        bytes calldata uri\n    ) external;\n\n    // Withdraw a portion of the accumulated fees for the provider msg.sender.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdraw(uint128 amount) external;\n\n    // Withdraw a portion of the accumulated fees for provider. The msg.sender must be the fee manager for this provider.\n    // Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n    // balance of fees in the contract).\n    function withdrawAsFeeManager(address provider, uint128 amount) external;\n\n    // As a user, request a random number from `provider`. Prior to calling this method, the user should\n    // generate a random number x and keep it secret. The user should then compute hash(x) and pass that\n    // as the userCommitment argument. (You may call the constructUserCommitment method to compute the hash.)\n    //\n    // This method returns a sequence number. The user should pass this sequence number to\n    // their chosen provider (the exact method for doing so will depend on the provider) to retrieve the provider's\n    // number. The user should then call fulfillRequest to construct the final random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function request(\n        address provider,\n        bytes32 userCommitment,\n        bool useBlockHash\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Request a random number. The method expects the provider address and a secret random number\n    // in the arguments. It returns a sequence number.\n    //\n    // The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n    // The `entropyCallback` method on that interface will receive a callback with the generated random number.\n    //\n    // This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n    // Note that excess value is *not* refunded to the caller.\n    function requestWithCallback(\n        address provider,\n        bytes32 userRandomNumber\n    ) external payable returns (uint64 assignedSequenceNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness and provider's proof\n    // against the corresponding commitments in the in-flight request. If both values are validated, this function returns\n    // the corresponding random number.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    function reveal(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRevelation,\n        bytes32 providerRevelation\n    ) external returns (bytes32 randomNumber);\n\n    // Fulfill a request for a random number. This method validates the provided userRandomness\n    // and provider's revelation against the corresponding commitment in the in-flight request. If both values are validated\n    // and the requestor address is a contract address, this function calls the requester's entropyCallback method with the\n    // sequence number, provider address and the random number as arguments. Else if the requestor is an EOA, it won't call it.\n    //\n    // Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n    // request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n    // If you need to use the returned random number more than once, you are responsible for storing it.\n    //\n    // Anyone can call this method to fulfill a request, but the callback will only be made to the original requester.\n    function revealWithCallback(\n        address provider,\n        uint64 sequenceNumber,\n        bytes32 userRandomNumber,\n        bytes32 providerRevelation\n    ) external;\n\n    function getProviderInfo(\n        address provider\n    ) external view returns (EntropyStructs.ProviderInfo memory info);\n\n    function getDefaultProvider() external view returns (address provider);\n\n    function getRequest(\n        address provider,\n        uint64 sequenceNumber\n    ) external view returns (EntropyStructs.Request memory req);\n\n    function getFee(address provider) external view returns (uint128 feeAmount);\n\n    function getAccruedPythFees()\n        external\n        view\n        returns (uint128 accruedPythFeesInWei);\n\n    function setProviderFee(uint128 newFeeInWei) external;\n\n    function setProviderFeeAsFeeManager(\n        address provider,\n        uint128 newFeeInWei\n    ) external;\n\n    function setProviderUri(bytes calldata newUri) external;\n\n    // Set manager as the fee manager for the provider msg.sender.\n    // After calling this function, manager will be able to set the provider's fees and withdraw them.\n    // Only one address can be the fee manager for a provider at a time -- calling this function again with a new value\n    // will override the previous value. Call this function with the all-zero address to disable the fee manager role.\n    function setFeeManager(address manager) external;\n\n    function constructUserCommitment(\n        bytes32 userRandomness\n    ) external pure returns (bytes32 userCommitment);\n\n    function combineRandomValues(\n        bytes32 userRandomness,\n        bytes32 providerRandomness,\n        bytes32 blockHash\n    ) external pure returns (bytes32 combinedRandomness);\n}\n"
    },
    "@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\npragma solidity ^0.8.0;\n\nabstract contract IEntropyConsumer {\n    // This method is called by Entropy to provide the random number to the consumer.\n    // It asserts that the msg.sender is the Entropy contract. It is not meant to be\n    // override by the consumer.\n    function _entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) external {\n        address entropy = getEntropy();\n        require(entropy != address(0), \"Entropy address not set\");\n        require(msg.sender == entropy, \"Only Entropy can call this function\");\n\n        entropyCallback(sequence, provider, randomNumber);\n    }\n\n    // getEntropy returns Entropy contract address. The method is being used to check that the\n    // callback is indeed from Entropy contract. The consumer is expected to implement this method.\n    // Entropy address can be found here - https://docs.pyth.network/entropy/contract-addresses\n    function getEntropy() internal view virtual returns (address);\n\n    // This method is expected to be implemented by the consumer to handle the random number.\n    // It will be called by _entropyCallback after _entropyCallback ensures that the call is\n    // indeed from Entropy contract.\n    function entropyCallback(\n        uint64 sequence,\n        address provider,\n        bytes32 randomNumber\n    ) internal virtual;\n}\n"
    },
    "contracts/Arga.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport {LibDiamond} from './libraries/LibDiamond.sol';\r\nimport {IDiamondCut} from './interfaces/IDiamondCut.sol';\r\n\r\ncontract Arga {\r\n\tconstructor(address _contractOwner, address _diamondCutFacet) payable {\r\n\t\tLibDiamond.setContractOwner(_contractOwner);\r\n\r\n\t\t// Add the diamondCut external function from the diamondCutFacet\r\n\t\tIDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n\t\tbytes4[] memory functionSelectors = new bytes4[](1);\r\n\t\tfunctionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n\t\tcut[0] = IDiamondCut.FacetCut({\r\n\t\t\tfacetAddress: _diamondCutFacet,\r\n\t\t\taction: IDiamondCut.FacetCutAction.Add,\r\n\t\t\tfunctionSelectors: functionSelectors\r\n\t\t});\r\n\t\tLibDiamond.diamondCut(cut, address(0), '');\r\n\t}\r\n\r\n\t// Find facet for function that is called and execute the\r\n\t// function if a facet is found and return any value.\r\n\tfallback() external payable {\r\n\t\tLibDiamond.DiamondStorage storage ds;\r\n\t\tbytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n\t\t// get diamond storage\r\n\t\tassembly {\r\n\t\t\tds.slot := position\r\n\t\t}\r\n\t\t// get facet from function selector\r\n\t\taddress facet = address(bytes20(ds.facets[msg.sig]));\r\n\t\trequire(facet != address(0), 'Diamond: Function does not exist');\r\n\t\t// Execute external function from facet using delegatecall and return any value.\r\n\t\tassembly {\r\n\t\t\t// copy function selector and any arguments\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\t\t\t// execute function call using the facet\r\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n\t\t\t// get any return value\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\t\t\t// return any return value or error back to the caller\r\n\t\t\tswitch result\r\n\t\t\tcase 0 {\r\n\t\t\t\trevert(0, returndatasize())\r\n\t\t\t}\r\n\t\t\tdefault {\r\n\t\t\t\treturn(0, returndatasize())\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treceive() external payable {}\r\n}\r\n"
    },
    "contracts/Entropy.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport '@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol';\nimport '@pythnetwork/entropy-sdk-solidity/EntropyErrors.sol';\nimport '@pythnetwork/entropy-sdk-solidity/EntropyEvents.sol';\nimport '@pythnetwork/entropy-sdk-solidity/IEntropy.sol';\nimport '@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol';\nimport '@openzeppelin/contracts/utils/math/SafeCast.sol';\nimport './EntropyState.sol';\n\n// Entropy implements a secure 2-party random number generation procedure. The protocol\n// is an extension of a simple commit/reveal protocol. The original version has the following steps:\n//\n// 1. Two parties A and B each draw a random number x_{A,B}\n// 2. A and B then share h_{A,B} = hash(x_{A,B})\n// 3. A and B reveal x_{A,B}\n// 4. Both parties verify that hash(x_{A, B}) == h_{A,B}\n// 5. The random number r = hash(x_A, x_B)\n//\n// This protocol has the property that the result is random as long as either A or B are honest.\n// Thus, neither party needs to trust the other -- as long as they are themselves honest, they can\n// ensure that the result r is random.\n//\n// Entropy implements a version of this protocol that is optimized for on-chain usage. The\n// key difference is that one of the participants (the provider) commits to a sequence of random numbers\n// up-front using a hash chain. Users of the protocol then simply grab the next random number in the sequence.\n//\n// Setup: The provider P computes a sequence of N random numbers, x_i (i = 0...N-1):\n// x_{N-1} = random()\n// x_i = hash(x_{i + 1})\n// The provider commits to x_0 by posting it to the contract. Each random number in the sequence can then be\n// verified against the previous one in the sequence by hashing it, i.e., hash(x_i) == x_{i - 1}\n//\n// Request: To produce a random number, the following steps occur.\n// 1. The user draws a random number x_U, and submits h_U = hash(x_U) to this contract\n// 2. The contract remembers h_U and assigns it an incrementing sequence number i, representing which\n//    of the provider's random numbers the user will receive.\n// 3. The user submits an off-chain request (e.g. via HTTP) to the provider to reveal the i'th random number.\n// 4. The provider checks the on-chain sequence number and ensures it is > i. If it is not, the provider\n//    refuses to reveal the ith random number. The provider should wait for a sufficient number of block confirmations\n//    to ensure that the request does not get re-orged out of the blockchain.\n// 5. The provider reveals x_i to the user.\n// 6. The user submits both the provider's revealed number x_i and their own x_U to the contract.\n// 7. The contract verifies hash(x_i) == x_{i-1} to prove that x_i is the i'th random number. The contract also checks that hash(x_U) == h_U.\n//    The contract stores x_i as the i'th random number to reuse for future verifications.\n// 8. If both of the above conditions are satisfied, the random number r = hash(x_i, x_U).\n//    (Optional) as an added security mechanism, this step can further incorporate the blockhash of the block that the\n//    request transaction landed in: r = hash(x_i, x_U, blockhash).\n//\n// This protocol has the same security properties as the 2-party randomness protocol above: as long as either\n// the provider or user is honest, the number r is random. Honesty here means that the participant keeps their\n// random number x a secret until the revelation phase (step 5) of the protocol. Note that providers need to\n// be careful to ensure their off-chain service isn't compromised to reveal the random numbers -- if this occurs,\n// then users will be able to influence the random number r.\n//\n// The Entropy implementation of the above protocol allows anyone to permissionlessly register to be a\n// randomness provider. Users then choose which provider to request randomness from. Each provider can set\n// their own fee for the service. In addition, the Entropy contract charges a flat fee that goes to the\n// Pyth protocol for each requested random number. Fees are paid in the native token of the network.\n//\n// This implementation has two intricacies that merit further explanation. First, the implementation supports\n// multiple concurrent requests for randomness by checking the provider's random number against their last known\n// random number. Verification therefore may require computing multiple hashes (~ the number of concurrent requests).\n// Second, the implementation allows providers to rotate their commitment at any time. This operation allows\n// providers to commit to additional random numbers once they reach the end of their initial sequence, or rotate out\n// a compromised sequence. On rotation, any in-flight requests continue to use the pre-rotation commitment.\n// Providers can use the sequence number of the request along with the event log of their registrations to determine\n// which hash chain contains the requested random number.\n//\n// Warning to integrators:\n// An important caveat of this protocol is that the user can compute the random number r before\n// revealing their own number to the contract. This property means that the user can choose to halt the\n// protocol prior to the random number being revealed (i.e., prior to step (6) above). Integrators should ensure that\n// the user is always incentivized to reveal their random number, and that the protocol has an escape hatch for\n// cases where the user chooses not to reveal.\nabstract contract Entropy is IEntropy, EntropyState {\n\tfunction _initialize(\n\t\taddress admin,\n\t\tuint128 pythFeeInWei,\n\t\taddress defaultProvider,\n\t\tbool prefillRequestStorage\n\t) internal {\n\t\trequire(admin != address(0), 'admin is zero address');\n\t\trequire(defaultProvider != address(0), 'defaultProvider is zero address');\n\n\t\t_state.admin = admin;\n\t\t_state.accruedPythFeesInWei = 0;\n\t\t_state.pythFeeInWei = pythFeeInWei;\n\t\t_state.defaultProvider = defaultProvider;\n\n\t\tif (prefillRequestStorage) {\n\t\t\t// Write some data to every storage slot in the requests array such that new requests\n\t\t\t// use a more consistent amount of gas.\n\t\t\t// Note that these requests are not live because their sequenceNumber is 0.\n\t\t\tfor (uint8 i = 0; i < NUM_REQUESTS; i++) {\n\t\t\t\tEntropyStructs.Request storage req = _state.requests[i];\n\t\t\t\treq.provider = address(1);\n\t\t\t\treq.blockNumber = 1234;\n\t\t\t\treq.commitment = hex'0123';\n\t\t\t}\n\t\t}\n\t}\n\n\t// Register msg.sender as a randomness provider. The arguments are the provider's configuration parameters\n\t// and initial commitment. Re-registering the same provider rotates the provider's commitment (and updates\n\t// the feeInWei).\n\t//\n\t// chainLength is the number of values in the hash chain *including* the commitment, that is, chainLength >= 1.\n\tfunction register(\n\t\tuint128 feeInWei,\n\t\tbytes32 commitment,\n\t\tbytes calldata commitmentMetadata,\n\t\tuint64 chainLength,\n\t\tbytes calldata uri\n\t) public override {\n\t\tif (chainLength == 0) revert EntropyErrors.AssertionFailure();\n\n\t\tEntropyStructs.ProviderInfo storage provider = _state.providers[msg.sender];\n\n\t\t// NOTE: this method implementation depends on the fact that ProviderInfo will be initialized to all-zero.\n\t\t// Specifically, accruedFeesInWei is intentionally not set. On initial registration, it will be zero,\n\t\t// then on future registrations, it will be unchanged. Similarly, provider.sequenceNumber defaults to 0\n\t\t// on initial registration.\n\n\t\tprovider.feeInWei = feeInWei;\n\n\t\tprovider.originalCommitment = commitment;\n\t\tprovider.originalCommitmentSequenceNumber = provider.sequenceNumber;\n\t\tprovider.currentCommitment = commitment;\n\t\tprovider.currentCommitmentSequenceNumber = provider.sequenceNumber;\n\t\tprovider.commitmentMetadata = commitmentMetadata;\n\t\tprovider.endSequenceNumber = provider.sequenceNumber + chainLength;\n\t\tprovider.uri = uri;\n\n\t\tprovider.sequenceNumber += 1;\n\n\t\temit Registered(provider);\n\t}\n\n\t// Withdraw a portion of the accumulated fees for the provider msg.sender.\n\t// Calling this function will transfer `amount` wei to the caller (provided that they have accrued a sufficient\n\t// balance of fees in the contract).\n\tfunction withdraw(uint128 amount) public override {\n\t\tEntropyStructs.ProviderInfo storage providerInfo = _state.providers[msg.sender];\n\n\t\t// Use checks-effects-interactions pattern to prevent reentrancy attacks.\n\t\trequire(providerInfo.accruedFeesInWei >= amount, 'Insufficient balance');\n\t\tproviderInfo.accruedFeesInWei -= amount;\n\n\t\t// Interaction with an external contract or token transfer\n\t\t(bool sent, ) = msg.sender.call{value: amount}('');\n\t\trequire(sent, 'withdrawal to msg.sender failed');\n\n\t\temit Withdrawal(msg.sender, msg.sender, amount);\n\t}\n\n\tfunction withdrawAsFeeManager(address provider, uint128 amount) external override {\n\t\tEntropyStructs.ProviderInfo storage providerInfo = _state.providers[provider];\n\n\t\tif (providerInfo.sequenceNumber == 0) {\n\t\t\trevert EntropyErrors.NoSuchProvider();\n\t\t}\n\n\t\tif (providerInfo.feeManager != msg.sender) {\n\t\t\trevert EntropyErrors.Unauthorized();\n\t\t}\n\n\t\t// Use checks-effects-interactions pattern to prevent reentrancy attacks.\n\t\trequire(providerInfo.accruedFeesInWei >= amount, 'Insufficient balance');\n\t\tproviderInfo.accruedFeesInWei -= amount;\n\n\t\t// Interaction with an external contract or token transfer\n\t\t(bool sent, ) = msg.sender.call{value: amount}('');\n\t\trequire(sent, 'withdrawal to msg.sender failed');\n\n\t\temit Withdrawal(provider, msg.sender, amount);\n\t}\n\n\t// requestHelper allocates and returns a new request for the given provider.\n\t// Note: This method will revert unless the caller provides a sufficient fee\n\t// (at least getFee(provider)) as msg.value.\n\tfunction requestHelper(\n\t\taddress provider,\n\t\tbytes32 userCommitment,\n\t\tbool useBlockhash,\n\t\tbool isRequestWithCallback\n\t) internal returns (EntropyStructs.Request storage req) {\n\t\tEntropyStructs.ProviderInfo storage providerInfo = _state.providers[provider];\n\t\tif (_state.providers[provider].sequenceNumber == 0) revert EntropyErrors.NoSuchProvider();\n\n\t\t// Assign a sequence number to the request\n\t\tuint64 assignedSequenceNumber = providerInfo.sequenceNumber;\n\t\tif (assignedSequenceNumber >= providerInfo.endSequenceNumber) revert EntropyErrors.OutOfRandomness();\n\t\tproviderInfo.sequenceNumber += 1;\n\n\t\t// Check that fees were paid and increment the pyth / provider balances.\n\t\tuint128 requiredFee = getFee(provider);\n\t\tif (msg.value < requiredFee) revert EntropyErrors.InsufficientFee();\n\t\tproviderInfo.accruedFeesInWei += providerInfo.feeInWei;\n\t\t_state.accruedPythFeesInWei += (SafeCast.toUint128(msg.value) - providerInfo.feeInWei);\n\n\t\t// Store the user's commitment so that we can fulfill the request later.\n\t\t// Warning: this code needs to overwrite *every* field in the request, because the returned request can be\n\t\t// filled with arbitrary data.\n\t\treq = allocRequest(provider, assignedSequenceNumber);\n\t\treq.provider = provider;\n\t\treq.sequenceNumber = assignedSequenceNumber;\n\t\treq.numHashes = SafeCast.toUint32(assignedSequenceNumber - providerInfo.currentCommitmentSequenceNumber);\n\t\treq.commitment = keccak256(bytes.concat(userCommitment, providerInfo.currentCommitment));\n\t\treq.requester = msg.sender;\n\n\t\treq.blockNumber = SafeCast.toUint64(block.number);\n\t\treq.useBlockhash = useBlockhash;\n\t\treq.isRequestWithCallback = isRequestWithCallback;\n\t}\n\n\t// As a user, request a random number from `provider`. Prior to calling this method, the user should\n\t// generate a random number x and keep it secret. The user should then compute hash(x) and pass that\n\t// as the userCommitment argument. (You may call the constructUserCommitment method to compute the hash.)\n\t//\n\t// This method returns a sequence number. The user should pass this sequence number to\n\t// their chosen provider (the exact method for doing so will depend on the provider) to retrieve the provider's\n\t// number. The user should then call fulfillRequest to construct the final random number.\n\t//\n\t// This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n\t// Note that excess value is *not* refunded to the caller.\n\tfunction request(\n\t\taddress provider,\n\t\tbytes32 userCommitment,\n\t\tbool useBlockHash\n\t) public payable override returns (uint64 assignedSequenceNumber) {\n\t\tEntropyStructs.Request storage req = requestHelper(provider, userCommitment, useBlockHash, false);\n\t\tassignedSequenceNumber = req.sequenceNumber;\n\t\temit Requested(req);\n\t}\n\n\t// Request a random number. The method expects the provider address and a secret random number\n\t// in the arguments. It returns a sequence number.\n\t//\n\t// The address calling this function should be a contract that inherits from the IEntropyConsumer interface.\n\t// The `entropyCallback` method on that interface will receive a callback with the generated random number.\n\t//\n\t// This method will revert unless the caller provides a sufficient fee (at least getFee(provider)) as msg.value.\n\t// Note that excess value is *not* refunded to the caller.\n\tfunction requestWithCallback(address provider, bytes32 userRandomNumber) public payable override returns (uint64) {\n\t\tEntropyStructs.Request storage req = requestHelper(\n\t\t\tprovider,\n\t\t\tconstructUserCommitment(userRandomNumber),\n\t\t\t// If useBlockHash is set to true, it allows a scenario in which the provider and miner can collude.\n\t\t\t// If we remove the blockHash from this, the provider would have no choice but to provide its committed\n\t\t\t// random number. Hence, useBlockHash is set to false.\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\n\t\temit RequestedWithCallback(provider, req.requester, req.sequenceNumber, userRandomNumber, req);\n\n\t\treturn req.sequenceNumber;\n\t}\n\n\t// This method validates the provided user's revelation and provider's revelation against the corresponding\n\t// commitment in the in-flight request. If both values are validated, this method will update the provider\n\t// current commitment and returns the generated random number.\n\tfunction revealHelper(\n\t\tEntropyStructs.Request storage req,\n\t\tbytes32 userRevelation,\n\t\tbytes32 providerRevelation\n\t) internal returns (bytes32 randomNumber, bytes32 blockHash) {\n\t\tbytes32 providerCommitment = constructProviderCommitment(req.numHashes, providerRevelation);\n\t\tbytes32 userCommitment = constructUserCommitment(userRevelation);\n\t\tif (keccak256(bytes.concat(userCommitment, providerCommitment)) != req.commitment)\n\t\t\trevert EntropyErrors.IncorrectRevelation();\n\n\t\tblockHash = bytes32(uint256(0));\n\t\tif (req.useBlockhash) {\n\t\t\tbytes32 _blockHash = blockhash(req.blockNumber);\n\n\t\t\t// The `blockhash` function will return zero if the req.blockNumber is equal to the current\n\t\t\t// block number, or if it is not within the 256 most recent blocks. This allows the user to\n\t\t\t// select between two random numbers by executing the reveal function in the same block as the\n\t\t\t// request, or after 256 blocks. This gives each user two chances to get a favorable result on\n\t\t\t// each request.\n\t\t\t// Revert this transaction for when the blockHash is 0;\n\t\t\tif (_blockHash == bytes32(uint256(0))) revert EntropyErrors.BlockhashUnavailable();\n\n\t\t\tblockHash = _blockHash;\n\t\t}\n\n\t\trandomNumber = combineRandomValues(userRevelation, providerRevelation, blockHash);\n\n\t\tEntropyStructs.ProviderInfo storage providerInfo = _state.providers[req.provider];\n\t\tif (providerInfo.currentCommitmentSequenceNumber < req.sequenceNumber) {\n\t\t\tproviderInfo.currentCommitmentSequenceNumber = req.sequenceNumber;\n\t\t\tproviderInfo.currentCommitment = providerRevelation;\n\t\t}\n\t}\n\n\t// Fulfill a request for a random number. This method validates the provided userRandomness and provider's proof\n\t// against the corresponding commitments in the in-flight request. If both values are validated, this function returns\n\t// the corresponding random number.\n\t//\n\t// Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n\t// request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n\t// If you need to use the returned random number more than once, you are responsible for storing it.\n\t//\n\t// This function must be called by the same `msg.sender` that originally requested the random number. This check\n\t// prevents denial-of-service attacks where another actor front-runs the requester's reveal transaction.\n\tfunction reveal(\n\t\taddress provider,\n\t\tuint64 sequenceNumber,\n\t\tbytes32 userRevelation,\n\t\tbytes32 providerRevelation\n\t) public override returns (bytes32 randomNumber) {\n\t\tEntropyStructs.Request storage req = findActiveRequest(provider, sequenceNumber);\n\n\t\tif (req.isRequestWithCallback) {\n\t\t\trevert EntropyErrors.InvalidRevealCall();\n\t\t}\n\n\t\tif (req.requester != msg.sender) {\n\t\t\trevert EntropyErrors.Unauthorized();\n\t\t}\n\t\tbytes32 blockHash;\n\t\t(randomNumber, blockHash) = revealHelper(req, userRevelation, providerRevelation);\n\t\temit Revealed(req, userRevelation, providerRevelation, blockHash, randomNumber);\n\t\tclearRequest(provider, sequenceNumber);\n\t}\n\n\t// Fulfill a request for a random number. This method validates the provided userRandomness\n\t// and provider's revelation against the corresponding commitment in the in-flight request. If both values are validated\n\t// and the requestor address is a contract address, this function calls the requester's entropyCallback method with the\n\t// sequence number, provider address and the random number as arguments. Else if the requestor is an EOA, it won't call it.\n\t//\n\t// Note that this function can only be called once per in-flight request. Calling this function deletes the stored\n\t// request information (so that the contract doesn't use a linear amount of storage in the number of requests).\n\t// If you need to use the returned random number more than once, you are responsible for storing it.\n\t//\n\t// Anyone can call this method to fulfill a request, but the callback will only be made to the original requester.\n\tfunction revealWithCallback(\n\t\taddress provider,\n\t\tuint64 sequenceNumber,\n\t\tbytes32 userRandomNumber,\n\t\tbytes32 providerRevelation\n\t) public override {\n\t\tEntropyStructs.Request storage req = findActiveRequest(provider, sequenceNumber);\n\n\t\tif (!req.isRequestWithCallback) {\n\t\t\trevert EntropyErrors.InvalidRevealCall();\n\t\t}\n\t\tbytes32 blockHash;\n\t\tbytes32 randomNumber;\n\t\t(randomNumber, blockHash) = revealHelper(req, userRandomNumber, providerRevelation);\n\n\t\taddress callAddress = req.requester;\n\n\t\temit RevealedWithCallback(req, userRandomNumber, providerRevelation, randomNumber);\n\n\t\tclearRequest(provider, sequenceNumber);\n\n\t\t// Check if the callAddress is a contract account.\n\t\tuint len;\n\t\tassembly {\n\t\t\tlen := extcodesize(callAddress)\n\t\t}\n\t\tif (len != 0) {\n\t\t\tIEntropyConsumer(callAddress)._entropyCallback(sequenceNumber, provider, randomNumber);\n\t\t}\n\t}\n\n\tfunction getProviderInfo(address provider) public view override returns (EntropyStructs.ProviderInfo memory info) {\n\t\tinfo = _state.providers[provider];\n\t}\n\n\tfunction getDefaultProvider() public view override returns (address provider) {\n\t\tprovider = _state.defaultProvider;\n\t}\n\n\tfunction getRequest(\n\t\taddress provider,\n\t\tuint64 sequenceNumber\n\t) public view override returns (EntropyStructs.Request memory req) {\n\t\treq = findRequest(provider, sequenceNumber);\n\t}\n\n\tfunction getFee(address provider) public view override returns (uint128 feeAmount) {\n\t\treturn _state.providers[provider].feeInWei + _state.pythFeeInWei;\n\t}\n\n\tfunction getPythFee() public view returns (uint128 feeAmount) {\n\t\treturn _state.pythFeeInWei;\n\t}\n\n\tfunction getAccruedPythFees() public view override returns (uint128 accruedPythFeesInWei) {\n\t\treturn _state.accruedPythFeesInWei;\n\t}\n\n\t// Set provider fee. It will revert if provider is not registered.\n\tfunction setProviderFee(uint128 newFeeInWei) external override {\n\t\tEntropyStructs.ProviderInfo storage provider = _state.providers[msg.sender];\n\n\t\tif (provider.sequenceNumber == 0) {\n\t\t\trevert EntropyErrors.NoSuchProvider();\n\t\t}\n\t\tuint128 oldFeeInWei = provider.feeInWei;\n\t\tprovider.feeInWei = newFeeInWei;\n\t\temit ProviderFeeUpdated(msg.sender, oldFeeInWei, newFeeInWei);\n\t}\n\n\tfunction setProviderFeeAsFeeManager(address provider, uint128 newFeeInWei) external override {\n\t\tEntropyStructs.ProviderInfo storage providerInfo = _state.providers[provider];\n\n\t\tif (providerInfo.sequenceNumber == 0) {\n\t\t\trevert EntropyErrors.NoSuchProvider();\n\t\t}\n\n\t\tif (providerInfo.feeManager != msg.sender) {\n\t\t\trevert EntropyErrors.Unauthorized();\n\t\t}\n\n\t\tuint128 oldFeeInWei = providerInfo.feeInWei;\n\t\tproviderInfo.feeInWei = newFeeInWei;\n\n\t\temit ProviderFeeUpdated(provider, oldFeeInWei, newFeeInWei);\n\t}\n\n\t// Set provider uri. It will revert if provider is not registered.\n\tfunction setProviderUri(bytes calldata newUri) external override {\n\t\tEntropyStructs.ProviderInfo storage provider = _state.providers[msg.sender];\n\t\tif (provider.sequenceNumber == 0) {\n\t\t\trevert EntropyErrors.NoSuchProvider();\n\t\t}\n\t\tbytes memory oldUri = provider.uri;\n\t\tprovider.uri = newUri;\n\t\temit ProviderUriUpdated(msg.sender, oldUri, newUri);\n\t}\n\n\tfunction setFeeManager(address manager) external override {\n\t\tEntropyStructs.ProviderInfo storage provider = _state.providers[msg.sender];\n\t\tif (provider.sequenceNumber == 0) {\n\t\t\trevert EntropyErrors.NoSuchProvider();\n\t\t}\n\n\t\taddress oldFeeManager = provider.feeManager;\n\t\tprovider.feeManager = manager;\n\t\temit ProviderFeeManagerUpdated(msg.sender, oldFeeManager, manager);\n\t}\n\n\tfunction constructUserCommitment(bytes32 userRandomness) public pure override returns (bytes32 userCommitment) {\n\t\tuserCommitment = keccak256(bytes.concat(userRandomness));\n\t}\n\n\tfunction combineRandomValues(\n\t\tbytes32 userRandomness,\n\t\tbytes32 providerRandomness,\n\t\tbytes32 blockHash\n\t) public pure override returns (bytes32 combinedRandomness) {\n\t\tcombinedRandomness = keccak256(abi.encodePacked(userRandomness, providerRandomness, blockHash));\n\t}\n\n\t// Create a unique key for an in-flight randomness request. Returns both a long key for use in the requestsOverflow\n\t// mapping and a short key for use in the requests array.\n\tfunction requestKey(address provider, uint64 sequenceNumber) internal pure returns (bytes32 hash, uint8 shortHash) {\n\t\thash = keccak256(abi.encodePacked(provider, sequenceNumber));\n\t\tshortHash = uint8(hash[0] & NUM_REQUESTS_MASK);\n\t}\n\n\t// Construct a provider's commitment given their revealed random number and the distance in the hash chain\n\t// between the commitment and the revealed random number.\n\tfunction constructProviderCommitment(\n\t\tuint64 numHashes,\n\t\tbytes32 revelation\n\t) internal pure returns (bytes32 currentHash) {\n\t\tcurrentHash = revelation;\n\t\twhile (numHashes > 0) {\n\t\t\tcurrentHash = keccak256(bytes.concat(currentHash));\n\t\t\tnumHashes -= 1;\n\t\t}\n\t}\n\n\t// Find an in-flight active request for given the provider and the sequence number.\n\t// This method returns a reference to the request, and will revert if the request is\n\t// not active.\n\tfunction findActiveRequest(\n\t\taddress provider,\n\t\tuint64 sequenceNumber\n\t) internal view returns (EntropyStructs.Request storage req) {\n\t\treq = findRequest(provider, sequenceNumber);\n\n\t\t// Check there is an active request for the given provider and sequence number.\n\t\tif (!isActive(req) || req.provider != provider || req.sequenceNumber != sequenceNumber)\n\t\t\trevert EntropyErrors.NoSuchRequest();\n\t}\n\n\t// Find an in-flight request.\n\t// Note that this method can return requests that are not currently active. The caller is responsible for checking\n\t// that the returned request is active (if they care).\n\tfunction findRequest(\n\t\taddress provider,\n\t\tuint64 sequenceNumber\n\t) internal view returns (EntropyStructs.Request storage req) {\n\t\t(bytes32 key, uint8 shortKey) = requestKey(provider, sequenceNumber);\n\n\t\treq = _state.requests[shortKey];\n\t\tif (req.provider == provider && req.sequenceNumber == sequenceNumber) {\n\t\t\treturn req;\n\t\t} else {\n\t\t\treq = _state.requestsOverflow[key];\n\t\t}\n\t}\n\n\t// Clear the storage for an in-flight request, deleting it from the hash table.\n\tfunction clearRequest(address provider, uint64 sequenceNumber) internal {\n\t\t(bytes32 key, uint8 shortKey) = requestKey(provider, sequenceNumber);\n\n\t\tEntropyStructs.Request storage req = _state.requests[shortKey];\n\t\tif (req.provider == provider && req.sequenceNumber == sequenceNumber) {\n\t\t\treq.sequenceNumber = 0;\n\t\t} else {\n\t\t\tdelete _state.requestsOverflow[key];\n\t\t}\n\t}\n\n\t// Allocate storage space for a new in-flight request. This method returns a pointer to a storage slot\n\t// that the caller should overwrite with the new request. Note that the memory at this storage slot may\n\t// -- and will -- be filled with arbitrary values, so the caller *must* overwrite every field of the returned\n\t// struct.\n\tfunction allocRequest(\n\t\taddress provider,\n\t\tuint64 sequenceNumber\n\t) internal returns (EntropyStructs.Request storage req) {\n\t\t(, uint8 shortKey) = requestKey(provider, sequenceNumber);\n\n\t\treq = _state.requests[shortKey];\n\t\tif (isActive(req)) {\n\t\t\t// There's already a prior active request in the storage slot we want to use.\n\t\t\t// Overflow the prior request to the requestsOverflow mapping.\n\t\t\t// It is important that this code overflows the *prior* request to the mapping, and not the new request.\n\t\t\t// There is a chance that some requests never get revealed and remain active forever. We do not want such\n\t\t\t// requests to fill up all of the space in the array and cause all new requests to incur the higher gas cost\n\t\t\t// of the mapping.\n\t\t\t//\n\t\t\t// This operation is expensive, but should be rare. If overflow happens frequently, increase\n\t\t\t// the size of the requests array to support more concurrent active requests.\n\t\t\t(bytes32 reqKey, ) = requestKey(req.provider, req.sequenceNumber);\n\t\t\t_state.requestsOverflow[reqKey] = req;\n\t\t}\n\t}\n\n\t// Returns true if a request is active, i.e., its corresponding random value has not yet been revealed.\n\tfunction isActive(EntropyStructs.Request storage req) internal view returns (bool) {\n\t\t// Note that a provider's initial registration occupies sequence number 0, so there is no way to construct\n\t\t// a randomness request with sequence number 0.\n\t\treturn req.sequenceNumber != 0;\n\t}\n}\n"
    },
    "contracts/EntropyState.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nimport '@pythnetwork/entropy-sdk-solidity/EntropyStructs.sol';\n\ncontract EntropyInternalStructs {\n\tstruct State {\n\t\t// Admin has the rights to update pyth configs\n\t\taddress admin;\n\t\t// Fee charged by the pyth protocol in wei.\n\t\tuint128 pythFeeInWei;\n\t\t// Total quantity of fees (in wei) earned by the pyth protocol that are currently stored in the contract.\n\t\t// This quantity is incremented when fees are paid and decremented when fees are withdrawn.\n\t\t// Note that u128 can store up to ~10^36 wei, which is ~10^18 in native base tokens, which should be plenty.\n\t\tuint128 accruedPythFeesInWei;\n\t\t// The protocol sets a provider as default to simplify integration for developers.\n\t\taddress defaultProvider;\n\t\t// Hash table for storing in-flight requests. Table keys are hash(provider, sequenceNumber), and the value is\n\t\t// the current request (if one is currently in-flight).\n\t\t//\n\t\t// Due to the vagaries of EVM opcode costs, it is inefficient to simply use a mapping here. Overwriting zero-valued\n\t\t// storage slots with non-zero values is expensive in EVM (21k gas). Using a mapping, each new request starts\n\t\t// from all-zero values, and thus incurs a substantial write cost. Deleting non-zero values does refund gas, but\n\t\t// unfortunately the refund is not substantial enough to matter.\n\t\t//\n\t\t// This data structure is a two-level hash table. It first tries to store new requests in the requests array at\n\t\t// an index determined by a few bits of the request's key. If that slot in the array is already occupied by a\n\t\t// prior request, the prior request is evicted into the requestsOverflow mapping. Requests in the array are\n\t\t// considered active if their sequenceNumber is > 0.\n\t\t//\n\t\t// WARNING: the number of requests must be kept in sync with the constants below\n\t\tEntropyStructs.Request[32] requests;\n\t\tmapping(bytes32 => EntropyStructs.Request) requestsOverflow;\n\t\t// Mapping from randomness providers to information about each them.\n\t\tmapping(address => EntropyStructs.ProviderInfo) providers;\n\t\t// proposedAdmin is the new admin's account address proposed by either the owner or the current admin.\n\t\t// If there is no pending transfer request, this value will hold `address(0)`.\n\t\taddress proposedAdmin;\n\t}\n}\n\ncontract EntropyState {\n\t// The size of the requests hash table. Must be a power of 2.\n\tuint8 public constant NUM_REQUESTS = 32;\n\tbytes1 public constant NUM_REQUESTS_MASK = 0x1f;\n\n\tEntropyInternalStructs.State _state;\n}\n"
    },
    "contracts/facets-arga/DeclarationFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport '@openzeppelin/contracts/utils/math/Math.sol';\r\n\r\nimport {ArgaLibrary} from '../libraries/ArgaLibrary.sol';\r\nimport {RedemptionLibrary} from './RedemptionFacet.sol';\r\nimport {PoolLibrary} from './PoolFacet.sol';\r\nimport {TreasuryLibrary} from './TreasuryFacet.sol';\r\n\r\nlibrary DeclarationLibrary {\r\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.declaration.storage');\r\n\r\n\tstruct State {\r\n\t\tArgaLibrary.Declaration[] declarations;\r\n\t\tmapping(address => uint[]) actorDeclarations;\r\n\t\tmapping(address => uint[]) witnessDeclarations;\r\n\t}\r\n\r\n\tfunction diamondStorage() internal pure returns (State storage ds) {\r\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\r\n\t\tassembly {\r\n\t\t\tds.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract DeclarationFacet {\r\n\tfunction getDeclaration(uint index) external view returns (ArgaLibrary.Declaration memory) {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\treturn ds.declarations[index];\r\n\t}\r\n\r\n\t// we store indices of declarations per actor address\r\n\tfunction actorDeclarations(address actor) external view returns (ArgaLibrary.Declaration[] memory) {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tuint[] storage indices = ds.actorDeclarations[actor];\r\n\t\tArgaLibrary.Declaration[] memory result = new ArgaLibrary.Declaration[](indices.length);\r\n\t\tfor (uint index; index < indices.length; index++) {\r\n\t\t\tresult[index] = ds.declarations[indices[index]];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\t// TODO: lastActorDeclaration\r\n\r\n\t// we store indices of declarations per witness address\r\n\tfunction witnessDeclarations(address witness) external view returns (ArgaLibrary.Declaration[] memory) {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tuint[] storage indices = ds.witnessDeclarations[witness];\r\n\t\tArgaLibrary.Declaration[] memory result = new ArgaLibrary.Declaration[](indices.length);\r\n\t\tfor (uint index; index < indices.length; index++) {\r\n\t\t\tresult[index] = ds.declarations[indices[index]];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction communityDeclarations(address actor, uint amount) external view returns (ArgaLibrary.Declaration[] memory) {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tuint[] storage indices = ds.actorDeclarations[actor];\r\n\t\tuint resultLength = Math.max(Math.min(amount, ds.declarations.length - indices.length), 0);\r\n\t\tArgaLibrary.Declaration[] memory result = new ArgaLibrary.Declaration[](resultLength);\r\n\t\tuint resultIndex = 0;\r\n\t\tuint declarationIndex = ds.declarations.length - 1;\r\n\t\twhile (resultIndex < resultLength) {\r\n\t\t\tArgaLibrary.Declaration memory foundDeclaration = ds.declarations[declarationIndex];\r\n\t\t\tif (foundDeclaration.actor == actor || foundDeclaration.actor == address(0)) {\r\n\t\t\t\tif (declarationIndex == 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tdeclarationIndex--;\r\n\t\t\t\tresultIndex++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tresult[resultIndex] = foundDeclaration;\r\n\t\t\tif (declarationIndex == 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tdeclarationIndex--;\r\n\t\t\tresultIndex++;\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\tfunction declareWithEther(\r\n\t\tstring memory summary,\r\n\t\tstring memory description,\r\n\t\taddress actor,\r\n\t\taddress witness,\r\n\t\tuint startDate,\r\n\t\tuint endDate,\r\n\t\tuint witnessByDate\r\n\t) external payable returns (ArgaLibrary.Declaration memory) {\r\n\t\tif (witness == address(0)) {\r\n\t\t\trevert ArgaLibrary.InvalidWitness(witness);\r\n\t\t}\r\n\t\tif (actor == address(0)) {\r\n\t\t\trevert ArgaLibrary.InvalidActor(actor);\r\n\t\t}\r\n\t\trequire(actor != address(0), \"can't use zero address for actor\");\r\n\t\trequire(endDate >= startDate, 'endDate must be after startDate');\r\n\t\trequire(witnessByDate >= endDate, 'witnessByDate must be after endDate');\r\n\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tuint declarationIndex = ds.declarations.length;\r\n\t\tArgaLibrary.Declaration memory declaration = ArgaLibrary.Declaration(\r\n\t\t\tdeclarationIndex,\r\n\t\t\tArgaLibrary.DeclarationStatus.Active,\r\n\t\t\tsummary,\r\n\t\t\tdescription,\r\n\t\t\tactor,\r\n\t\t\twitness,\r\n\t\t\tstartDate,\r\n\t\t\tendDate,\r\n\t\t\twitnessByDate,\r\n\t\t\tArgaLibrary.Collateral(msg.value, address(0)),\r\n\t\t\t'',\r\n\t\t\tuint64(0)\r\n\t\t);\r\n\t\temit ArgaLibrary.DeclarationMade(declaration);\r\n\t\tds.declarations.push(declaration);\r\n\t\tds.actorDeclarations[actor].push(declarationIndex);\r\n\t\tds.witnessDeclarations[witness].push(declarationIndex);\r\n\t\treturn declaration;\r\n\t}\r\n\r\n\tfunction submitDeclarationProof(uint id, string memory proof) external returns (ArgaLibrary.Declaration memory) {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tArgaLibrary.Declaration storage declaration = ds.declarations[id];\r\n\t\trequire(msg.sender == declaration.actor, 'only actor can submit proof');\r\n\t\tdeclaration.proof = proof;\r\n\t\tdeclaration.status = ArgaLibrary.DeclarationStatus.ProofSubmitted;\r\n\t\temit ArgaLibrary.DeclarationStatusChange(declaration);\r\n\t\treturn declaration;\r\n\t}\r\n\r\n\tfunction concludeDeclarationWithApproval(uint id, bytes32 randomNumber) external {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tRedemptionLibrary.State storage rds = RedemptionLibrary.diamondStorage();\r\n\t\tTreasuryLibrary.State storage tds = TreasuryLibrary.diamondStorage();\r\n\t\tArgaLibrary.Declaration storage declaration = ds.declarations[id];\r\n\t\tif (msg.sender != declaration.witness) {\r\n\t\t\trevert ArgaLibrary.InvalidWitness(msg.sender);\r\n\t\t}\r\n\t\trequire(declaration.status == ArgaLibrary.DeclarationStatus.ProofSubmitted, 'proof not submitted yet');\r\n\t\trequire(declaration.witnessByDate > block.timestamp, 'witness by date has passed');\r\n\r\n\t\tdeclaration.status = ArgaLibrary.DeclarationStatus.Approved;\r\n\t\temit ArgaLibrary.DeclarationStatusChange(declaration);\r\n\r\n\t\t// distribute collateral to relevant parties\r\n\t\tuint treasurerValue = (declaration.collateral.value * tds.treasurerRedemptionPercentage) / 100;\r\n\t\tuint witnessValue = (declaration.collateral.value * tds.witnessRedemptionPercentage) / 100;\r\n\t\tuint actorValue = declaration.collateral.value - treasurerValue - witnessValue;\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\trds.redemptions[tds.treasurer],\r\n\t\t\tArgaLibrary.Collateral(treasurerValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\trds.redemptions[declaration.witness],\r\n\t\t\tArgaLibrary.Collateral(treasurerValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\trds.redemptions[declaration.actor],\r\n\t\t\tArgaLibrary.Collateral(actorValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\r\n\t\t// draw and keep drawId\r\n\t\tuint64 drawId = PoolLibrary.maybeWinPool(declaration, tds.treasurerRedemptionPercentage, randomNumber);\r\n\t\tdeclaration.drawId = drawId;\r\n\t}\r\n\r\n\tfunction concludeDeclarationWithRejection(uint id, bytes32 randomNumber) external {\r\n\t\tDeclarationLibrary.State storage ds = DeclarationLibrary.diamondStorage();\r\n\t\tRedemptionLibrary.State storage rds = RedemptionLibrary.diamondStorage();\r\n\t\tTreasuryLibrary.State storage tds = TreasuryLibrary.diamondStorage();\r\n\t\tPoolLibrary.State storage pds = PoolLibrary.diamondStorage();\r\n\t\tArgaLibrary.Declaration storage declaration = ds.declarations[id];\r\n\t\tif (msg.sender != declaration.witness) {\r\n\t\t\trevert ArgaLibrary.InvalidWitness(msg.sender);\r\n\t\t}\r\n\r\n\t\tdeclaration.status = ArgaLibrary.DeclarationStatus.Rejected;\r\n\t\temit ArgaLibrary.DeclarationStatusChange(declaration);\r\n\r\n\t\t// distribute collateral to relevant parties\r\n\t\tuint treasurerValue = (declaration.collateral.value * tds.treasurerRedemptionPercentage) / 100;\r\n\t\tuint witnessValue = (declaration.collateral.value * tds.witnessRedemptionPercentage) / 100;\r\n\t\tuint poolValue = declaration.collateral.value - treasurerValue - witnessValue;\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\tpds.pool,\r\n\t\t\tArgaLibrary.Collateral(poolValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\trds.redemptions[tds.treasurer],\r\n\t\t\tArgaLibrary.Collateral(treasurerValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\t\tArgaLibrary.addToCollateralsSingle(\r\n\t\t\trds.redemptions[declaration.witness],\r\n\t\t\tArgaLibrary.Collateral(treasurerValue, declaration.collateral.erc20Address)\r\n\t\t);\r\n\r\n\t\t// draw and keep drawId\r\n\t\tuint64 drawId = PoolLibrary.maybeWinPool(declaration, tds.treasurerRedemptionPercentage, randomNumber);\r\n\t\tdeclaration.drawId = drawId;\r\n\t}\r\n}\r\n"
    },
    "contracts/facets-arga/PoolFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\r\nimport {ArgaLibrary} from '../libraries/ArgaLibrary.sol';\r\nimport {RedemptionLibrary} from './RedemptionFacet.sol';\r\nimport {DeclarationLibrary} from './DeclarationFacet.sol';\r\nimport {TreasuryLibrary} from './TreasuryFacet.sol';\r\n\r\nimport {IEntropyConsumer} from '@pythnetwork/entropy-sdk-solidity/IEntropyConsumer.sol';\r\nimport {IEntropy} from '@pythnetwork/entropy-sdk-solidity/IEntropy.sol';\r\n\r\nlibrary PoolLibrary {\r\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.pool.storage');\r\n\tbytes32 constant POOL_STORAGE_POSITION = keccak256('diamond.standard.pool.storage.pool');\r\n\r\n\tstruct State {\r\n\t\tArgaLibrary.Collateral[] pool;\r\n\t\tuint winMultiplier;\r\n\t\taddress entropyProvider;\r\n\t\taddress entropyContractAddress;\r\n\t\tIEntropy entropy;\r\n\t\tmapping(uint64 => ArgaLibrary.Draw) draws;\r\n\t}\r\n\r\n\tfunction diamondStorage() internal pure returns (State storage ds) {\r\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\r\n\t\tassembly {\r\n\t\t\tds.slot := position\r\n\t\t}\r\n\t}\r\n\r\n\tfunction poolStorage() internal pure returns (ArgaLibrary.Collateral[] storage pool) {\r\n\t\tbytes32 position = POOL_STORAGE_POSITION;\r\n\t\tassembly {\r\n\t\t\tpool.slot := position\r\n\t\t}\r\n\t}\r\n\r\n\t// rename to draw\r\n\tfunction maybeWinPool(\r\n\t\tArgaLibrary.Declaration memory declaration,\r\n\t\tuint feesTotalPercent,\r\n\t\tbytes32 randomNumber\r\n\t) internal returns (uint64) {\r\n\t\tState storage ds = diamondStorage();\r\n\t\tif (ds.pool.length == 0) return uint64(0);\r\n\r\n\t\t// take entropy fee from treasury\r\n\t\tuint fee = ds.entropy.getFee(ds.entropyProvider);\r\n\t\tRedemptionLibrary.State storage rds = RedemptionLibrary.diamondStorage();\r\n\t\tTreasuryLibrary.State storage tds = TreasuryLibrary.diamondStorage();\r\n\t\tArgaLibrary.Collateral memory feeCollateral = ArgaLibrary.Collateral(fee, address(0));\r\n\t\tArgaLibrary.removeFromCollateralsSingle(rds.redemptions[tds.treasurer], feeCollateral);\r\n\r\n\t\tuint64 drawId = ds.entropy.requestWithCallback{value: fee}(ds.entropyProvider, randomNumber);\r\n\t\tuint chanceToWin = (declaration.collateral.value / ds.pool[0].value) * feesTotalPercent * ds.winMultiplier;\r\n\t\tArgaLibrary.Draw storage draw = ds.draws[drawId];\r\n\t\tdraw.declarationId = declaration.id;\r\n\t\tdraw.chanceToWin = chanceToWin;\r\n\t\tdraw.pool = ds.pool;\r\n\t\temit ArgaLibrary.PoolDrawn(drawId);\r\n\t\treturn drawId;\r\n\t}\r\n}\r\n\r\ncontract PoolFacet is IEntropyConsumer {\r\n\tfunction pool() external view returns (ArgaLibrary.Collateral[] memory) {\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\treturn ds.pool;\r\n\t}\r\n\r\n\tfunction winMultiplier() external view returns (uint) {\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\treturn ds.winMultiplier;\r\n\t}\r\n\r\n\tfunction draw(uint64 drawId) external view returns (ArgaLibrary.Draw memory) {\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\treturn ds.draws[drawId];\r\n\t}\r\n\r\n\tfunction changeWinMultiplier(uint _winMultiplier) external {\r\n\t\tLibDiamond.enforceIsContractOwner();\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\tds.winMultiplier = _winMultiplier;\r\n\t}\r\n\r\n\tfunction getEntropy() internal view override returns (address) {\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\treturn address(ds.entropy);\r\n\t}\r\n\r\n\tfunction entropyCallback(uint64 drawId, address, bytes32 randomNumber) internal override {\r\n\t\tPoolLibrary.State storage ds = PoolLibrary.diamondStorage();\r\n\t\tif (msg.sender != getEntropy()) {\r\n\t\t\trevert ArgaLibrary.InvalidEntropyContract(msg.sender);\r\n\t\t}\r\n\t\tDeclarationLibrary.State storage dds = DeclarationLibrary.diamondStorage();\r\n\t\tArgaLibrary.Draw storage _draw = ds.draws[drawId];\r\n\t\tArgaLibrary.Declaration storage declaration = dds.declarations[_draw.declarationId];\r\n\t\t_draw.value = uint256(randomNumber) % 100;\r\n\t\tif (_draw.value > _draw.chanceToWin) {\r\n\t\t\t// lost\r\n\t\t\t_draw.status = ArgaLibrary.DrawStatus.Lost;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// won\r\n\t\t// transfer from pool to redemptions\r\n\t\tRedemptionLibrary.State storage rds = RedemptionLibrary.diamondStorage();\r\n\t\tArgaLibrary.addToCollateralsMultiple(rds.redemptions[declaration.actor], _draw.pool);\r\n\t\t// remove from pool\r\n\t\tArgaLibrary.removeFromCollateralsMultiple(ds.pool, _draw.pool);\r\n\t\t_draw.status = ArgaLibrary.DrawStatus.Won;\r\n\t}\r\n}\r\n"
    },
    "contracts/facets-arga/RedemptionFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {ArgaLibrary} from '../libraries/ArgaLibrary.sol';\n\nlibrary RedemptionLibrary {\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.redemption.storage');\n\n\tstruct State {\n\t\tmapping(address => ArgaLibrary.Collateral[]) redemptions;\n\t}\n\n\tfunction diamondStorage() internal pure returns (State storage ds) {\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n}\n\ncontract RedemptionFacet {\n\tfunction redemptionsForParty(address party) external view returns (ArgaLibrary.Collateral[] memory) {\n\t\tRedemptionLibrary.State storage ds = RedemptionLibrary.diamondStorage();\n\t\treturn ds.redemptions[party];\n\t}\n\n\tfunction redeem(address payable destination, address[] calldata erc20Addresses) external {\n\t\tRedemptionLibrary.State storage ds = RedemptionLibrary.diamondStorage();\n\t\taddress party = msg.sender;\n\t\tArgaLibrary.Collateral[] storage collaterals = ds.redemptions[party];\n\t\tfor (uint i = 0; i < erc20Addresses.length; i++) {\n\t\t\taddress erc20Address = erc20Addresses[i];\n\t\t\tbool success;\n\t\t\tfor (uint ii = 0; ii < collaterals.length; ii++) {\n\t\t\t\tArgaLibrary.Collateral storage collateral = collaterals[ii];\n\t\t\t\tif (collateral.erc20Address != erc20Address) continue;\n\t\t\t\tif (erc20Address == address(0)) {\n\t\t\t\t\t// ether\n\t\t\t\t\trequire(collateral.value > 0, 'No ETH available to redeem');\n\t\t\t\t\t(bool sent, ) = destination.call{value: collateral.value, gas: 5000}('');\n\t\t\t\t\trequire(sent, 'Failed to send Ether');\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\tdelete collaterals[ii];\n\t\t\t\t} else {\n\t\t\t\t\t// token\n\t\t\t\t}\n\t\t\t}\n\t\t\trequire(success, 'No redemption found for address');\n\t\t}\n\t}\n}\n"
    },
    "contracts/facets-arga/TreasuryFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n\r\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\r\nimport {ArgaLibrary} from '../libraries/ArgaLibrary.sol';\r\nimport {DeclarationLibrary} from './DeclarationFacet.sol';\r\nimport {RedemptionLibrary} from './RedemptionFacet.sol';\r\nimport {PoolLibrary} from './PoolFacet.sol';\r\n\r\nlibrary TreasuryLibrary {\r\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.treasury.storage');\r\n\r\n\tstruct State {\r\n\t\taddress treasurer;\r\n\t\tuint256 treasurerRedemptionPercentage;\r\n\t\tuint256 witnessRedemptionPercentage;\r\n\t}\r\n\r\n\tfunction diamondStorage() internal pure returns (State storage ds) {\r\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\r\n\t\tassembly {\r\n\t\t\tds.slot := position\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract TreasuryFacet {\r\n\tfunction treasurer() external view returns (address _treasurer) {\r\n\t\tTreasuryLibrary.State storage ds = TreasuryLibrary.diamondStorage();\r\n\t\treturn ds.treasurer;\r\n\t}\r\n\r\n\tfunction changeTreasurer(address newTreasurer) external {\r\n\t\tif (newTreasurer == address(0)) {\r\n\t\t\trevert ArgaLibrary.ZeroAddress();\r\n\t\t}\r\n\t\tLibDiamond.enforceIsContractOwner();\r\n\t\tTreasuryLibrary.State storage ds = TreasuryLibrary.diamondStorage();\r\n\t\tds.treasurer = newTreasurer;\r\n\t\temit ArgaLibrary.TreasurerChanged(newTreasurer);\r\n\t}\r\n}\r\n"
    },
    "contracts/facets-diamond/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\n\ncontract DiamondCutFacet is IDiamondCut {\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external override {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tuint256 originalSelectorCount = ds.selectorCount;\n\t\tuint256 selectorCount = originalSelectorCount;\n\t\tbytes32 selectorSlot;\n\t\t// Check if last selector slot is not full\n\t\t// \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n\t\tif (selectorCount & 7 > 0) {\n\t\t\t// get last selectorSlot\n\t\t\t// \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n\t\t\tselectorSlot = ds.selectorSlots[selectorCount >> 3];\n\t\t}\n\t\t// loop through diamond cut\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n\t\t\t(selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n\t\t\t\tselectorCount,\n\t\t\t\tselectorSlot,\n\t\t\t\t_diamondCut[facetIndex].facetAddress,\n\t\t\t\t_diamondCut[facetIndex].action,\n\t\t\t\t_diamondCut[facetIndex].functionSelectors\n\t\t\t);\n\n\t\t\tunchecked {\n\t\t\t\tfacetIndex++;\n\t\t\t}\n\t\t}\n\t\tif (selectorCount != originalSelectorCount) {\n\t\t\tds.selectorCount = uint16(selectorCount);\n\t\t}\n\t\t// If last selector slot is not full\n\t\t// \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n\t\tif (selectorCount & 7 > 0) {\n\t\t\t// \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n\t\t\tds.selectorSlots[selectorCount >> 3] = selectorSlot;\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tLibDiamond.initializeDiamondCut(_init, _calldata);\n\t}\n}\n"
    },
    "contracts/facets-diamond/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\nimport {IDiamondLoupe} from '../interfaces/IDiamondLoupe.sol';\nimport {IERC165} from '../interfaces/IERC165.sol';\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n\t/// @notice Gets all facets and their selectors.\n\t/// @return facets_ Facet\n\tfunction facets() external view override returns (Facet[] memory facets_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacets_ = new Facet[](ds.selectorCount);\n\t\tuint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n\t\tuint256 numFacets;\n\t\tuint256 selectorIndex;\n\t\t// loop through function selectors\n\t\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n\t\t\tbytes32 slot = ds.selectorSlots[slotIndex];\n\t\t\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n\t\t\t\tselectorIndex++;\n\t\t\t\tif (selectorIndex > ds.selectorCount) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\t\t\t\taddress facetAddress_ = address(bytes20(ds.facets[selector]));\n\t\t\t\tbool continueLoop;\n\t\t\t\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n\t\t\t\t\tif (facets_[facetIndex].facetAddress == facetAddress_) {\n\t\t\t\t\t\tfacets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n\t\t\t\t\t\t// probably will never have more than 256 functions from one facet contract\n\t\t\t\t\t\trequire(numFacetSelectors[facetIndex] < 255);\n\t\t\t\t\t\tnumFacetSelectors[facetIndex]++;\n\t\t\t\t\t\tcontinueLoop = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueLoop) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfacets_[numFacets].facetAddress = facetAddress_;\n\t\t\t\tfacets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n\t\t\t\tfacets_[numFacets].functionSelectors[0] = selector;\n\t\t\t\tnumFacetSelectors[numFacets] = 1;\n\t\t\t\tnumFacets++;\n\t\t\t}\n\t\t}\n\t\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n\t\t\tuint256 numSelectors = numFacetSelectors[facetIndex];\n\t\t\tbytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n\t\t\t// setting the number of selectors\n\t\t\tassembly {\n\t\t\t\tmstore(selectors, numSelectors)\n\t\t\t}\n\t\t}\n\t\t// setting the number of facets\n\t\tassembly {\n\t\t\tmstore(facets_, numFacets)\n\t\t}\n\t}\n\n\t/// @notice Gets all the function selectors supported by a specific facet.\n\t/// @param _facet The facet address.\n\t/// @return _facetFunctionSelectors The selectors associated with a facet address.\n\tfunction facetFunctionSelectors(\n\t\taddress _facet\n\t) external view override returns (bytes4[] memory _facetFunctionSelectors) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tuint256 numSelectors;\n\t\t_facetFunctionSelectors = new bytes4[](ds.selectorCount);\n\t\tuint256 selectorIndex;\n\t\t// loop through function selectors\n\t\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n\t\t\tbytes32 slot = ds.selectorSlots[slotIndex];\n\t\t\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n\t\t\t\tselectorIndex++;\n\t\t\t\tif (selectorIndex > ds.selectorCount) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\t\t\t\taddress facet = address(bytes20(ds.facets[selector]));\n\t\t\t\tif (_facet == facet) {\n\t\t\t\t\t_facetFunctionSelectors[numSelectors] = selector;\n\t\t\t\t\tnumSelectors++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Set the number of selectors in the array\n\t\tassembly {\n\t\t\tmstore(_facetFunctionSelectors, numSelectors)\n\t\t}\n\t}\n\n\t/// @notice Get all the facet addresses used by a diamond.\n\t/// @return facetAddresses_\n\tfunction facetAddresses() external view override returns (address[] memory facetAddresses_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacetAddresses_ = new address[](ds.selectorCount);\n\t\tuint256 numFacets;\n\t\tuint256 selectorIndex;\n\t\t// loop through function selectors\n\t\tfor (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n\t\t\tbytes32 slot = ds.selectorSlots[slotIndex];\n\t\t\tfor (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n\t\t\t\tselectorIndex++;\n\t\t\t\tif (selectorIndex > ds.selectorCount) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\tbytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n\t\t\t\taddress facetAddress_ = address(bytes20(ds.facets[selector]));\n\t\t\t\tbool continueLoop;\n\t\t\t\tfor (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n\t\t\t\t\tif (facetAddress_ == facetAddresses_[facetIndex]) {\n\t\t\t\t\t\tcontinueLoop = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (continueLoop) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfacetAddresses_[numFacets] = facetAddress_;\n\t\t\t\tnumFacets++;\n\t\t\t}\n\t\t}\n\t\t// Set the number of facet addresses in the array\n\t\tassembly {\n\t\t\tmstore(facetAddresses_, numFacets)\n\t\t}\n\t}\n\n\t/// @notice Gets the facet that supports the given selector.\n\t/// @dev If facet is not found return address(0).\n\t/// @param _functionSelector The function selector.\n\t/// @return facetAddress_ The facet address.\n\tfunction facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\tfacetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n\t}\n\n\t// This implements ERC-165.\n\tfunction supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n\t\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\t\treturn ds.supportedInterfaces[_interfaceId];\n\t}\n}\n"
    },
    "contracts/facets-diamond/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\nimport {IERC173} from '../interfaces/IERC173.sol';\n\ncontract OwnershipFacet is IERC173 {\n\tfunction transferOwnership(address _newOwner) external override {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tif (_newOwner == address(0)) {\n\t\t\trevert LibDiamond.OwnableInvalidOwner(_newOwner);\n\t\t}\n\t\tLibDiamond.setContractOwner(_newOwner);\n\t}\n\n\tfunction owner() external view override returns (address owner_) {\n\t\towner_ = LibDiamond.contractOwner();\n\t}\n\n\tfunction renounceOwnership() external {\n\t\tLibDiamond.enforceIsContractOwner();\n\t\tLibDiamond.setContractOwner(address(0));\n\t}\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n\tenum FacetCutAction {\n\t\tAdd,\n\t\tReplace,\n\t\tRemove\n\t}\n\t// Add=0, Replace=1, Remove=2\n\n\tstruct FacetCut {\n\t\taddress facetAddress;\n\t\tFacetCutAction action;\n\t\tbytes4[] functionSelectors;\n\t}\n\n\t/// @notice Add/replace/remove any number of functions and optionally execute\n\t///         a function with delegatecall\n\t/// @param _diamondCut Contains the facet addresses and function selectors\n\t/// @param _init The address of the contract or facet to execute _calldata\n\t/// @param _calldata A function call, including function selector and arguments\n\t///                  _calldata is executed with delegatecall on _init\n\tfunction diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n\tevent DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n\t/// @notice Query if a contract implements an interface\n\t/// @param interfaceId The interface identifier, as specified in ERC-165\n\t/// @dev Interface identification is specified in ERC-165. This function\n\t///  uses less than 30,000 gas.\n\t/// @return `true` if the contract implements `interfaceID` and\n\t///  `interfaceID` is not 0xffffffff, `false` otherwise\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n\t/// @dev This emits when ownership of a contract changes.\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\t/// @notice Get the address of the owner\n\t/// @return owner_ The address of the owner.\n\tfunction owner() external view returns (address owner_);\n\n\t/// @notice Set the address of the new owner of the contract\n\t/// @dev Set _newOwner to address(0) to renounce any ownership.\n\t/// @param _newOwner The address of the new owner of the contract\n\tfunction transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/libraries/ArgaLibrary.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\nimport 'hardhat/console.sol';\n\npragma solidity ^0.8.22;\n\nlibrary ArgaLibrary {\n\tevent ParentContractChanged(address parentContract);\n\n\tevent DeclarationMade(Declaration declaration);\n\tevent DeclarationStatusChange(Declaration declaration);\n\n\tevent PoolDrawn(uint drawId);\n\tevent PoolWon(Declaration declaration);\n\terror InvalidEntropyContract(address sender);\n\tevent TreasurerChanged(address treasurer);\n\n\terror ZeroAddress();\n\terror InvalidWitness(address witness);\n\terror InvalidActor(address actor);\n\n\tstruct Collateral {\n\t\tuint value;\n\t\taddress erc20Address;\n\t}\n\tenum DeclarationStatus {\n\t\tActive,\n\t\tProofSubmitted,\n\t\tApproved,\n\t\tRejected\n\t}\n\tstruct Declaration {\n\t\tuint id;\n\t\tDeclarationStatus status;\n\t\tstring summary;\n\t\tstring description;\n\t\t// address sender;\n\t\t// uint group id;\n\t\taddress actor;\n\t\taddress witness;\n\t\t// uint witnessRedemptionValue;\n\t\tuint startDate;\n\t\tuint endDate;\n\t\tuint witnessByDate;\n\t\tCollateral collateral;\n\t\tstring proof;\n\t\tuint64 drawId;\n\t}\n\n\tenum DrawStatus {\n\t\tPending,\n\t\tLost,\n\t\tWon\n\t}\n\tstruct Draw {\n\t\tuint declarationId;\n\t\tCollateral[] pool;\n\t\tuint chanceToWin;\n\t\tDrawStatus status;\n\t\tuint value;\n\t}\n\n\tfunction addToCollateralsSingle(Collateral[] storage collaterals, Collateral memory collateral) internal {\n\t\t// try to add to existing collateral if exists\n\t\tfor (uint i = 0; i < collaterals.length; i++) {\n\t\t\tCollateral storage existingCollateral = collaterals[i];\n\t\t\tif (existingCollateral.erc20Address != collateral.erc20Address) continue;\n\t\t\texistingCollateral.value = existingCollateral.value + collateral.value;\n\t\t\treturn;\n\t\t}\n\t\t// otherwise add new collateral\n\t\tcollaterals.push(collateral);\n\t}\n\tfunction removeFromCollateralsSingle(Collateral[] storage collaterals, Collateral memory collateral) internal {\n\t\t// try to remove from existing collateral if exists\n\t\tfor (uint i = 0; i < collaterals.length; i++) {\n\t\t\tCollateral storage existingCollateral = collaterals[i];\n\t\t\tif (existingCollateral.erc20Address != collateral.erc20Address) continue;\n\t\t\texistingCollateral.value = existingCollateral.value - collateral.value;\n\t\t\treturn;\n\t\t}\n\t}\n\tfunction addToCollateralsMultiple(Collateral[] storage collaterals, Collateral[] memory newCollaterals) internal {\n\t\t// try to add to existing collateral if exists\n\t\tfor (uint i = 0; i < newCollaterals.length; i++) {\n\t\t\tfor (uint ii = 0; ii < collaterals.length; ii++) {\n\t\t\t\tCollateral storage existingCollateral = collaterals[ii];\n\t\t\t\tif (existingCollateral.erc20Address != newCollaterals[i].erc20Address) continue;\n\t\t\t\texistingCollateral.value = existingCollateral.value + newCollaterals[i].value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// otherwise add new collateral\n\t\t\tcollaterals.push(newCollaterals[i]);\n\t\t}\n\t}\n\tfunction removeFromCollateralsMultiple(\n\t\tCollateral[] storage collaterals,\n\t\tCollateral[] memory newCollaterals\n\t) internal {\n\t\t// try to remove from existing collateral if exists\n\t\tfor (uint i = 0; i < newCollaterals.length; i++) {\n\t\t\tfor (uint ii = 0; ii < collaterals.length; ii++) {\n\t\t\t\tCollateral storage existingCollateral = collaterals[ii];\n\t\t\t\tif (existingCollateral.erc20Address != newCollaterals[i].erc20Address) continue;\n\t\t\t\texistingCollateral.value = existingCollateral.value - newCollaterals[i].value;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\nimport {IERC173} from '../interfaces/IERC173.sol';\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n\tbytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.diamond.storage');\n\n\terror OwnableUnauthorizedAccount(address _invalidAddress);\n\terror OwnableInvalidOwner(address _owner);\n\n\tstruct DiamondStorage {\n\t\t// maps function selectors to the facets that execute the functions.\n\t\t// and maps the selectors to their position in the selectorSlots array.\n\t\t// func selector => address facet, selector position\n\t\tmapping(bytes4 => bytes32) facets;\n\t\t// array of slots of function selectors.\n\t\t// each slot holds 8 function selectors.\n\t\tmapping(uint256 => bytes32) selectorSlots;\n\t\t// The number of function selectors in selectorSlots\n\t\tuint16 selectorCount;\n\t\t// Used to query if a contract implements an interface.\n\t\t// Used to implement ERC-165.\n\t\tmapping(bytes4 => bool) supportedInterfaces;\n\t\t// owner of the contract\n\t\taddress contractOwner;\n\t}\n\n\tfunction diamondStorage() internal pure returns (DiamondStorage storage ds) {\n\t\tbytes32 position = DIAMOND_STORAGE_POSITION;\n\t\tassembly {\n\t\t\tds.slot := position\n\t\t}\n\t}\n\n\t// move ownership stuff to Ownership facet\n\tfunction setContractOwner(address _newOwner) internal {\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\taddress previousOwner = ds.contractOwner;\n\t\tds.contractOwner = _newOwner;\n\t\temit IERC173.OwnershipTransferred(previousOwner, _newOwner);\n\t}\n\n\tfunction contractOwner() internal view returns (address contractOwner_) {\n\t\tcontractOwner_ = diamondStorage().contractOwner;\n\t}\n\n\tfunction enforceIsContractOwner() internal view {\n\t\tif (msg.sender != diamondStorage().contractOwner) {\n\t\t\trevert OwnableUnauthorizedAccount(msg.sender);\n\t\t}\n\t}\n\n\tevent DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n\tbytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n\tbytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n\t// Internal function version of diamondCut\n\t// This code is almost the same as the external diamondCut,\n\t// except it is using 'Facet[] memory _diamondCut' instead of\n\t// 'Facet[] calldata _diamondCut'.\n\t// The code is duplicated to prevent copying calldata to memory which\n\t// causes an error for a two dimensional array.\n\tfunction diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\tuint256 originalSelectorCount = ds.selectorCount;\n\t\tuint256 selectorCount = originalSelectorCount;\n\t\tbytes32 selectorSlot;\n\t\t// Check if last selector slot is not full\n\t\t// \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n\t\tif (selectorCount & 7 > 0) {\n\t\t\t// get last selectorSlot\n\t\t\t// \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n\t\t\tselectorSlot = ds.selectorSlots[selectorCount >> 3];\n\t\t}\n\t\t// loop through diamond cut\n\t\tfor (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n\t\t\t(selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n\t\t\t\tselectorCount,\n\t\t\t\tselectorSlot,\n\t\t\t\t_diamondCut[facetIndex].facetAddress,\n\t\t\t\t_diamondCut[facetIndex].action,\n\t\t\t\t_diamondCut[facetIndex].functionSelectors\n\t\t\t);\n\n\t\t\tunchecked {\n\t\t\t\tfacetIndex++;\n\t\t\t}\n\t\t}\n\t\tif (selectorCount != originalSelectorCount) {\n\t\t\tds.selectorCount = uint16(selectorCount);\n\t\t}\n\t\t// If last selector slot is not full\n\t\t// \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n\t\tif (selectorCount & 7 > 0) {\n\t\t\t// \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n\t\t\tds.selectorSlots[selectorCount >> 3] = selectorSlot;\n\t\t}\n\t\temit DiamondCut(_diamondCut, _init, _calldata);\n\t\tinitializeDiamondCut(_init, _calldata);\n\t}\n\n\tfunction addReplaceRemoveFacetSelectors(\n\t\tuint256 _selectorCount,\n\t\tbytes32 _selectorSlot,\n\t\taddress _newFacetAddress,\n\t\tIDiamondCut.FacetCutAction _action,\n\t\tbytes4[] memory _selectors\n\t) internal returns (uint256, bytes32) {\n\t\tDiamondStorage storage ds = diamondStorage();\n\t\trequire(_selectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\n\t\tif (_action == IDiamondCut.FacetCutAction.Add) {\n\t\t\tenforceHasContractCode(_newFacetAddress, 'LibDiamondCut: Add facet has no code');\n\t\t\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n\t\t\t\tbytes4 selector = _selectors[selectorIndex];\n\t\t\t\tbytes32 oldFacet = ds.facets[selector];\n\t\t\t\trequire(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\t\t\t\t// add facet for selector\n\t\t\t\tds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n\t\t\t\t// \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\tuint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n\t\t\t\t// clear selector position in slot and add selector\n\t\t\t\t_selectorSlot =\n\t\t\t\t\t(_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n\t\t\t\t\t(bytes32(selector) >> selectorInSlotPosition);\n\t\t\t\t// if slot is full then write it to storage\n\t\t\t\tif (selectorInSlotPosition == 224) {\n\t\t\t\t\t// \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n\t\t\t\t\tds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n\t\t\t\t\t_selectorSlot = 0;\n\t\t\t\t}\n\t\t\t\t_selectorCount++;\n\n\t\t\t\tunchecked {\n\t\t\t\t\tselectorIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_action == IDiamondCut.FacetCutAction.Replace) {\n\t\t\tenforceHasContractCode(_newFacetAddress, 'LibDiamondCut: Replace facet has no code');\n\t\t\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n\t\t\t\tbytes4 selector = _selectors[selectorIndex];\n\t\t\t\tbytes32 oldFacet = ds.facets[selector];\n\t\t\t\taddress oldFacetAddress = address(bytes20(oldFacet));\n\t\t\t\t// only useful if immutable functions exist\n\t\t\t\trequire(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n\t\t\t\trequire(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n\t\t\t\trequire(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n\t\t\t\t// replace old facet address\n\t\t\t\tds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n\t\t\t\tunchecked {\n\t\t\t\t\tselectorIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (_action == IDiamondCut.FacetCutAction.Remove) {\n\t\t\trequire(_newFacetAddress == address(0), 'LibDiamondCut: Remove facet address must be address(0)');\n\t\t\t// \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n\t\t\tuint256 selectorSlotCount = _selectorCount >> 3;\n\t\t\t// \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n\t\t\tuint256 selectorInSlotIndex = _selectorCount & 7;\n\t\t\tfor (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n\t\t\t\tif (selectorInSlotIndex == 0) {\n\t\t\t\t\t// get last selectorSlot\n\t\t\t\t\tselectorSlotCount--;\n\t\t\t\t\t_selectorSlot = ds.selectorSlots[selectorSlotCount];\n\t\t\t\t\tselectorInSlotIndex = 7;\n\t\t\t\t} else {\n\t\t\t\t\tselectorInSlotIndex--;\n\t\t\t\t}\n\t\t\t\tbytes4 lastSelector;\n\t\t\t\tuint256 oldSelectorsSlotCount;\n\t\t\t\tuint256 oldSelectorInSlotPosition;\n\t\t\t\t// adding a block here prevents stack too deep error\n\t\t\t\t{\n\t\t\t\t\tbytes4 selector = _selectors[selectorIndex];\n\t\t\t\t\tbytes32 oldFacet = ds.facets[selector];\n\t\t\t\t\trequire(\n\t\t\t\t\t\taddress(bytes20(oldFacet)) != address(0),\n\t\t\t\t\t\t\"LibDiamondCut: Can't remove function that doesn't exist\"\n\t\t\t\t\t);\n\t\t\t\t\t// only useful if immutable functions exist\n\t\t\t\t\trequire(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n\t\t\t\t\t// replace selector with last selector in ds.facets\n\t\t\t\t\t// gets the last selector\n\t\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\t\tlastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n\t\t\t\t\tif (lastSelector != selector) {\n\t\t\t\t\t\t// update last selector slot position info\n\t\t\t\t\t\tds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n\t\t\t\t\t}\n\t\t\t\t\tdelete ds.facets[selector];\n\t\t\t\t\tuint256 oldSelectorCount = uint16(uint256(oldFacet));\n\t\t\t\t\t// \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n\t\t\t\t\toldSelectorsSlotCount = oldSelectorCount >> 3;\n\t\t\t\t\t// \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n\t\t\t\t\t// \" << 5 is the same as multiplying by 32 ( * 32)\n\t\t\t\t\toldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n\t\t\t\t}\n\t\t\t\tif (oldSelectorsSlotCount != selectorSlotCount) {\n\t\t\t\t\tbytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n\t\t\t\t\t// clears the selector we are deleting and puts the last selector in its place.\n\t\t\t\t\toldSelectorSlot =\n\t\t\t\t\t\t(oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n\t\t\t\t\t\t(bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\t\t\t\t\t// update storage with the modified slot\n\t\t\t\t\tds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n\t\t\t\t} else {\n\t\t\t\t\t// clears the selector we are deleting and puts the last selector in its place.\n\t\t\t\t\t_selectorSlot =\n\t\t\t\t\t\t(_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n\t\t\t\t\t\t(bytes32(lastSelector) >> oldSelectorInSlotPosition);\n\t\t\t\t}\n\t\t\t\tif (selectorInSlotIndex == 0) {\n\t\t\t\t\tdelete ds.selectorSlots[selectorSlotCount];\n\t\t\t\t\t_selectorSlot = 0;\n\t\t\t\t}\n\n\t\t\t\tunchecked {\n\t\t\t\t\tselectorIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n\t\t} else {\n\t\t\trevert('LibDiamondCut: Incorrect FacetCutAction');\n\t\t}\n\t\treturn (_selectorCount, _selectorSlot);\n\t}\n\n\tfunction initializeDiamondCut(address _init, bytes memory _calldata) internal {\n\t\tif (_init == address(0)) {\n\t\t\treturn;\n\t\t}\n\t\tenforceHasContractCode(_init, 'LibDiamondCut: _init address has no code');\n\t\t(bool success, bytes memory error) = _init.delegatecall(_calldata);\n\t\tif (!success) {\n\t\t\tif (error.length > 0) {\n\t\t\t\t// bubble up error\n\t\t\t\t/// @solidity memory-safe-assembly\n\t\t\t\tassembly {\n\t\t\t\t\tlet returndata_size := mload(error)\n\t\t\t\t\trevert(add(32, error), returndata_size)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trevert InitializationFunctionReverted(_init, _calldata);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n\t\tuint256 contractSize;\n\t\tassembly {\n\t\t\tcontractSize := extcodesize(_contract)\n\t\t}\n\t\trequire(contractSize > 0, _errorMessage);\n\t}\n}\n"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\r\nimport {IDiamondLoupe} from '../interfaces/IDiamondLoupe.sol';\r\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\r\nimport {IERC173} from '../interfaces/IERC173.sol';\r\nimport {IERC165} from '../interfaces/IERC165.sol';\r\n\r\nimport {TreasuryLibrary} from '../facets-arga/TreasuryFacet.sol';\r\nimport {PoolLibrary} from '../facets-arga/PoolFacet.sol';\r\nimport {IEntropy} from '@pythnetwork/entropy-sdk-solidity/IEntropy.sol';\r\n\r\ncontract DiamondInit {\r\n\terror WrongEntropyContractAddress(address entropyContractAddress);\r\n\r\n\tfunction isContract(address _addr) public view returns (bool) {\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n\r\n\tfunction init(address treasurer, address entropyContractAddress) external {\r\n\t\t// adding ERC165 data\r\n\t\tLibDiamond.DiamondStorage storage lds = LibDiamond.diamondStorage();\r\n\t\tlds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n\t\tlds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n\t\tlds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n\t\tlds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n\t\tTreasuryLibrary.State storage tds = TreasuryLibrary.diamondStorage();\r\n\t\t// TODO: check if already initialized or not\r\n\t\ttds.treasurer = treasurer;\r\n\t\ttds.treasurerRedemptionPercentage = 2;\r\n\t\ttds.witnessRedemptionPercentage = 2;\r\n\r\n\t\tPoolLibrary.State storage pds = PoolLibrary.diamondStorage();\r\n\t\tpds.winMultiplier = 1;\r\n\t\tpds.entropyContractAddress = entropyContractAddress;\r\n\t\tif (!isContract(entropyContractAddress)) {\r\n\t\t\trevert WrongEntropyContractAddress(entropyContractAddress);\r\n\t\t}\r\n\t\tpds.entropy = IEntropy(pds.entropyContractAddress);\r\n\t\tpds.entropyProvider = pds.entropy.getDefaultProvider();\r\n\t}\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}